{"meta":{"title":"Ahser's Blog","subtitle":"","description":"","author":"John Doe","url":"http://zouyc.cn","root":"/"},"pages":[{"title":"分类","date":"2022-03-22T04:47:00.982Z","updated":"2022-03-22T04:47:00.982Z","comments":false,"path":"categories/index.html","permalink":"http://zouyc.cn/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-03-22T05:10:18.878Z","updated":"2022-03-22T05:10:18.878Z","comments":false,"path":"about/index.html","permalink":"http://zouyc.cn/about/index.html","excerpt":"","text":"一个热爱计算机，热爱编程的男生"},{"title":"标签","date":"2022-03-22T04:15:03.778Z","updated":"2022-03-22T04:15:03.778Z","comments":false,"path":"tags/index.html","permalink":"http://zouyc.cn/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-03-22T04:16:57.039Z","updated":"2022-03-22T04:16:57.039Z","comments":false,"path":"links/index.html","permalink":"http://zouyc.cn/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring","slug":"Spring","date":"2022-03-23T10:48:23.000Z","updated":"2022-03-23T12:24:40.387Z","comments":true,"path":"2022/03/23/Spring/","link":"","permalink":"http://zouyc.cn/2022/03/23/Spring/","excerpt":"","text":"IoC容器 Spring为我们提供了一个容器，用于管理所有的JavaBean组件，这是Spring框架最核心的概念 举个例子来说明IoC容器到底是啥： 假设现在有一个MemberService和BookService，现在它俩都需要操作数据库，用传统方式自然是在每个Service中都创建数据源实例，比如： 1234public class MemberService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 1234public class BookService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 在每个Service中都需要重复创建这些对象，随着Service越来越多，难道我们要一个个手动创建出来吗？完全可以共享同一个DataSource，那IoC就是用来解决这些问题的，在Ioc模式下控制权发生了反转，所有的组件都由容器负责，而不是我们自己手动创建，最简单的方式就是通过XML文件来实现： 123456789101112131415&lt;beans&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt; &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;memberService&quot; class=&quot;MemberService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在这个文件中创建了三个JavaBean组件，可以发现两个Service共享同一个数据源ref=&quot;dataSource&quot;，创建好Bean之后就需要使用了Bean了 依赖注入方式： 注入在IoC容器中管理的Bean，可通过set()或构造方法实现 1234567public class BookService &#123; private DataSource dataSource; public setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125;&#125; 创建Spring项目 通过maven创建即可，需引入spring-context依赖 12345678910111213141516171819202122232425262728&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;spring-ioc-appcontext&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 一个特定的application.xml文件，就是之前组装Bean的文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 最后得告诉容器为我们创建并装配好所有得Bean，在主启动类中添加以下代码 12345678910public static void main(String[] args) &#123; // 在resources目录下加载配置文件，并完成Bean的创建 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 获取Bean MemberService member = context.getBean(MemberService.class); // 调用方法 member.login(&quot;username&quot;,&quot;password&quot;);&#125; 使用注解配置 其实完全可以不用XML文件配置Bean，使用注解配置更加简单 直接在类上添加@Component注解： 123@Componentpublic class MailService &#123;&#125; 12345@Componentpublic class UserService &#123; @Autowired private MailService mailService;&#125; @Component就等于在容器中定义了一个Bean，默认名为首字母小写，@Autowired就等于使用set()进行依赖注入 由于没有了配置文件，所以主启动类中的加载方式也有了变化 1234567@Configuration@ComponentScanpublic class AppConfig &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); &#125;&#125; @Configuration表示它是一个配置类，等于application.xml，@ComponentScan用于扫描当前类以及所在子包所有标注了@Component的类并将其创建，一定要严格按照这个包结构来创建类 Scope Spring容器创建的Bean默认都是单例的，所以说通过context.getBean()获取的Bean都是同一个实例，我们也可以让它每次都返回一个新的实例，把这种Bean称为原型，在类上下面的注解即可 1@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 注入List 通过定义接口和实现类，将所有该类型的Bean都注入到一个List中 12public interface Validator &#123;&#125; 123@Componentpublic class NameValidator implements Validator &#123;&#125; 123@Componentpublic class PasswordValidator implements Validator &#123;&#125; 12345@Componentpublic class Validators &#123; @Autowired List&lt;Validator&gt; validators;&#125; Validator接口有两个实现类，在Validators中定义好了集合的泛型，通过@Autowired就可将所有Validator类型的Bean注入到一个List中 第三方Bean 用于一个Bean不在我们的包管理之内 123456789@Configuration@ComponentScanpublic class AppConfig &#123; // 创建一个Bean: @Bean ZoneId createZoneId() &#123; return ZoneId.of(&quot;Z&quot;); &#125;&#125; @Bean只调用一次，它返回的Bean也是单例的 初始化和销毁 用于一个Bean在被注入后进行初始化操作以及容器关闭时进行销毁操作，需引入一个特定依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112@Componentpublic class MailService &#123; @PostConstruct public void init() &#123; System.out.println(&quot;init&quot;); &#125; @PreDestroy public void shutdown() &#123; System.out.println(&quot;shutdown&quot;); &#125;&#125; 在MailService被注入后就会执行init()，在容器关闭时执行shutdown()，需调用close() Resource Spring提供了一个org.springframework.core.io.Resource用于读取配置文件 12@Value(&quot;classpath:/logo.txt&quot;)private Resource resource; 还有更简单的方式，使用注解： 123456@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123; @Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId;&#125; $&#123;app.zone:Z&#125;表示如果Key不存在就用默认值Z 条件装配 当满足特定条件创建Bean，使用@Conditional，看一个简单例子： 123@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;&#125; 如果配置文件中有app.smtp并且值为true才创建","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"}]},{"title":"泛型","slug":"泛型","date":"2022-03-22T06:53:39.000Z","updated":"2022-03-22T09:29:14.953Z","comments":true,"path":"2022/03/22/泛型/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"什么是泛型 泛型就是编写模板代码来适应类型，好处就是不必强制转型，通过编译器对类型进行检查 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 这就是泛型，集合限定了元素必须为String类型，否则报错 泛型接口 除了在集合中使用泛型，有许多接口也用到了泛型，比如 Comparable&lt;T&gt; 可以直接对String类型的数组进行排序，因为String实现了Comparable接口 1public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence 123String[] s = &#123;&quot;B&quot;, &quot;A&quot;, &quot;C&quot;&#125;;Arrays.sort(s);System.out.println(Arrays.toString(s)); 如何实习自定义类的排序呢？实现Comparable接口 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt;&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public int compareTo(Person o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试： 12345678910Person[] people = &#123;new Person(&quot;lucy&quot;, 21), new Person(&quot;mary&quot;, 19), new Person(&quot;Mali&quot;, 33)&#125;;System.out.println(&quot;排序前&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125;Arrays.sort(people);System.out.println(&quot;排序后&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125; 通过控制台输出就可以发现Person数组已经按照年龄进行了升序排序 编写泛型 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 注意静态方法不能使用&lt;T&gt;，应该与实例类型的泛型区分开： 123public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123; return new Pair&lt;K&gt;(first, last);&#125; 擦拭法 虚拟机对泛型是一无所知的，视所有泛型为Object，在需要转型的时候编译器会根据T类型自动为我们安全的强制转型 这就造成了使用泛型时一些的局限 不能是基本类型，因为Object无法持有基本类型 在获取class时因为擦拭法导致取到的对象是同一个对象 也无法判断泛型的类型 不能实例化泛型 可以借助Class&lt;T&gt;来实例化泛型对象 1234public Pair(Class&lt;T&gt; clazz) &#123; first = clazz.newInstance(); last = clazz.newInstance();&#125; 泛型继承 12345public class IntPair extends Pair&lt;Integer&gt; &#123; public IntPair(Integer first, Integer last) &#123; super(first, last); &#125;&#125; 子类获取父类的泛型类型： 12345678910public static void main(String[] args) &#123; Class&lt;IntPair&gt; clazz = IntPair.class; Type type = clazz.getGenericSuperclass(); // 获得带有泛型的父类 if (type instanceof ParameterizedType)&#123; // 判断是否为参数化类型，即泛型 ParameterizedType p = (ParameterizedType) type; Type[] types = p.getActualTypeArguments(); // 父类可能有多个泛型 Type firstType = types[0]; // 取第一个泛型 System.out.println(firstType.getTypeName()); &#125;&#125; extends 在平时的继承关系中Integer是Number的子类，但是在泛型中Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类 比如我们定义了一个方法，限定了传入的参数为Pair&lt;Number&gt;类型，如果传入Pair&lt;Integer&gt;就会报错 123static int add(Pair&lt;Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 1234public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p);&#125; 那如何传入Integer呢？这就需要用到extends通配符来解决了，改造一下那个方法 123static int add(Pair&lt;? extends Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 这种通配符被称为上界通配符，把泛型类型T的上界限定在了Number 使用extends须知： 在add()中是不能获取Integer的引用的，下面代码是无法通过编译的，要求你强制转型 1Integer first = p.getFirst(); 因为我们虽然限定了泛型的上界为Number，但是传入的具体类型到底是Integer还是其他Number的子类是不知道的，编译器只能确定一定是Number的子类 也无法传递Number的子类型给对象的set() 1p.setFirst(new Integer(p.getFirst().intValue() + 100)); 总结一下： 允许调用get()获取Number的引用 不允许调用set(? extends Number)传入任何Number的引用 super 正好和Number相反，传入的是Integer以及它的父类 1Pair&lt;? super Integer&gt; p 使用super须知： 1234567public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p,5);&#125;static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; p.setFirst(n);&#125; 这段代码是可以被正常编译的，因为限定了下界为Integer，无论传入Integer还是它的父类都是可以的 但是无法使用Integer接收get()的返回值，因为无法确定具体返回的是Integer还是它的父类，唯一可以接收的是Object 123static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; Object first = p.getFirst();&#125; 所以对比extends和super可以发现： &lt;? extends Number&gt;可读不可写 &lt;? super Integer&gt;可写不可读 补充 声明泛型数组时，不能用new操作符创建数组，需强制转型 1Pair&lt;Integer&gt;[] pairs = (Pair&lt;Integer&gt;[]) new Pair[2];","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2022-03-22T05:59:45.000Z","updated":"2022-03-22T12:19:53.883Z","comments":true,"path":"2022/03/22/函数式编程/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FunctionalInterface 我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口： 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 支持函数式编程的都可以使用Lambda表达式 Lambda表达式 当我们用Arrays.sort()排序时，可以传入一个Comparator实例，并采用匿名类的方式来实现： 123456String[] array = ...Arrays.sort(array, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); 但是这种写法还是挺繁琐的，所以从JDK8开始，我们可以用Lambda表达式来替代这种繁琐的写法： 1234String[] array = ...Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2);&#125;); 使用Lambda只需要写出方法的定义，参数类型可以省略，编译器会自动推断出String类型，-&gt; &#123; ... &#125;表示方法体，如果只有一行return代码，还可以更加简洁： 1Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2)); 返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。 方法引用 除了使用Lambda之外，还可以直接传入方法引用： 123456789public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(&quot;, &quot;, array));&#125;static int cmp(String s1, String s2) &#123; return s1.compareTo(s2);&#125; 上面的代码是啥意思？可以看到Arrays.sort需传入一个数组和Comparator接口，在Comparator中有个方法int compare(T o1, T o2)，我们自己定义的方法cmp和compare这个方法的方法签名一致，即方法参数和返回类型相同，就可以直接使用方法引用，再看一个例子： 12345public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, String::compareTo); System.out.println(String.join(&quot;, &quot;, array));&#125; 查看String的compareTo方法发现参数只有一个，但是前面不是说方法签名要一致吗，这又是怎么回事？因为之前的方法是个静态方法，这里是一个实例方法，实例方法第一个隐含参数总是传入this，相当于： 1public static int compareTo(this, String o); 所以String::compareTo和compare方法签名是一致的 Stream 一个全新的流失API，可以存储有限或无限个元素，Stream是惰性计算，计算通常时发生在最后结果的获取，因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果： 如何创建一个Stream? Stream.of 1Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;); 数组或Collection 12Stream&lt;String&gt; stream = Arrays.stream(new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;);Stream&lt;String&gt; stream1 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).stream(); Supplier 通过Stream.generate()需传入Supplier对象 12345public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);&#125; Supplier是一个函数式接口，我们可以自己实现这个接口 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 123456789class NatualSupplier implements Supplier&lt;Integer&gt; &#123; int n = 0; @Override public Integer get() &#123; return n++; &#125;&#125; 基于Supplier创建的Stream会不断调用get()产生下一个元素，可以用来表示无限序列 1234public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.generate(new NatualSupplier()); stream.limit(20).forEach(System.out::println);&#125; 因为它会不断调用get()，我们必须设定一个界限stream.limit(20) 基本类型 因为Java的泛型不支持基本类型的，只能用Integer等包装类型，但是Stream会对频繁的拆箱装箱，所以为了提高效率，Java标准库给我们提供了三种使用基本类型的Stream -&gt; IntStream、LongStream、DoubleStream map Stream.map()是一个转换方法，将一个Stream转为另一个Stream 12Stream&lt;Integer&gt; stream = List.of(1, 2, 3).stream();Stream&lt;Integer&gt; streamMap = stream.map(item -&gt; item * item); 我们看看map()，最终会返回一个新结果的Stream 1234567891011121314/** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;, * &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); Stream.map()传入的是函数式接口Function，apply()最终return计算的结果 123456789101112@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); ...&#125; filter Stream.filter()是Stream的另一个常用转换方法 filter即过滤，过滤掉不满足条件的元素，满足条件的构成一个新的Stream 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Stream&lt;Integer&gt; streamMap = stream.filter(item -&gt; item % 2 == 0); filter接收Predicate，test()过滤掉不满足条件的元素 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t);&#125; reduce 是Stream的一个聚合方法，把一个Stream的所有元素按照聚合函数聚合成一个结果 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Integer reduce = stream.reduce(0, (acc, n) -&gt; acc + n); Stream.reduce()接收BinaryOperator，而它又继承自BiFunction，在BiFunction中有R apply(T t, U u) 12345678/** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */R apply(T t, U u); 所以BinaryOperator实际上是重写了父接口的方法apply()，通过这个方法进行累加计算 第一个参数0相当于初始值，见源码注释： 123456* &lt;pre&gt;&#123;@code* T result = identity;* for (T element : this stream)* result = accumulator.apply(result, element)* return result;* &#125;&lt;/pre&gt; 输出Stream 对Stream做map()或filter()操作时是不会进行任何计算的，reduce会立即得出结果 如何把进行了转换操作的元素保存下来呢？ 输出为集合： collect()并传入Collectors.toList()对象： 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();List&lt;Integer&gt; list = stream.map(n -&gt; n * n).collect(Collectors.toList()); 输出为数组： 12Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;).stream();String[] array = stream.toArray(String[]::new); 输出为Map： 12345678Stream&lt;String&gt; stream = List.of(&quot;Apple:Banana&quot;, &quot;Pear:Peach&quot;).stream();Map&lt;String, String&gt; map = stream.collect(Collectors .toMap( // 映射为key s -&gt; s.substring(0, s.indexOf(&#x27;:&#x27;)), // 映射为value s -&gt; s.substring(s.indexOf(&#x27;:&#x27;) + 1) )); 分组输出： 123Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Blackberry&quot;, &quot;Coconut&quot;, &quot;Avocado&quot;, &quot;Cherry&quot;, &quot;Apricots&quot;).stream();Map&lt;String, List&lt;String&gt;&gt; groups = stream.collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList())); 上述代码中Collectors.groupingBy以元素的首字母为依据做一个分组","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]}