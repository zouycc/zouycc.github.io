{"meta":{"title":"Ahser's Blog","subtitle":"","description":"","author":"John Doe","url":"http://zouyc.xyz","root":"/"},"pages":[{"title":"分类","date":"2022-03-22T04:47:00.982Z","updated":"2022-03-22T04:47:00.982Z","comments":false,"path":"categories/index.html","permalink":"http://zouyc.xyz/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-03-22T05:10:18.878Z","updated":"2022-03-22T05:10:18.878Z","comments":false,"path":"about/index.html","permalink":"http://zouyc.xyz/about/index.html","excerpt":"","text":"一个热爱计算机，热爱编程的男生"},{"title":"标签","date":"2022-03-22T04:15:03.778Z","updated":"2022-03-22T04:15:03.778Z","comments":false,"path":"tags/index.html","permalink":"http://zouyc.xyz/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-03-22T04:16:57.039Z","updated":"2022-03-22T04:16:57.039Z","comments":false,"path":"links/index.html","permalink":"http://zouyc.xyz/links/index.html","excerpt":"","text":""}],"posts":[{"title":"函数式编程","slug":"函数式编程","date":"2022-03-22T05:59:45.000Z","updated":"2022-03-22T06:01:10.281Z","comments":true,"path":"2022/03/22/函数式编程/","link":"","permalink":"http://zouyc.xyz/2022/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FunctionalInterface我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口： 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 支持函数式编程的都可以使用Lambda表达式 Lambda表达式当我们用Arrays.sort()排序时，可以传入一个Comparator实例，并采用匿名类的方式来实现： 123456String[] array = ...Arrays.sort(array, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); 但是这种写法还是挺繁琐的，所以从JDK8开始，我们可以用Lambda表达式来替代这种繁琐的写法： 1234String[] array = ...Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2);&#125;); 使用Lambda只需要写出方法的定义，参数类型可以省略，编译器会自动推断出String类型，-&gt; { … }表示方法体，如果只有一行return代码，还可以更加简洁： 1Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2)); 返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。 方法引用除了使用Lambda之外，还可以直接传入方法引用： 123456789public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(&quot;, &quot;, array));&#125;static int cmp(String s1, String s2) &#123; return s1.compareTo(s2);&#125; 上面的代码是啥意思？可以看到Arrays.sort需传入一个数组和Comparator接口，在Comparator中有个方法int compare(T o1, T o2)，我们自己定义的方法cmp和compare这个方法的方法签名一致，即方法参数和返回类型相同，就可以直接使用方法引用，再看一个例子： 12345public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, String::compareTo); System.out.println(String.join(&quot;, &quot;, array));&#125; 查看String的compareTo方法发现参数只有一个，但是前面不是说方法签名要一致吗，这又是怎么回事？因为之前的方法是个静态方法，这里是一个实例方法，实例方法第一个隐含参数总是传入this，相当于： 1public static int compareTo(this, String o); 所以String::compareTo和compare方法签名是一致的","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.xyz/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.xyz/tags/Java/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.xyz/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.xyz/tags/Java/"}]}