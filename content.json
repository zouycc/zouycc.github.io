{"meta":{"title":"Ahser's Blog","subtitle":"","description":"","author":"John Doe","url":"http://zouyc.cn","root":"/"},"pages":[{"title":"关于我","date":"2022-03-22T05:10:18.878Z","updated":"2022-03-22T05:10:18.878Z","comments":false,"path":"about/index.html","permalink":"http://zouyc.cn/about/index.html","excerpt":"","text":"一个热爱计算机，热爱编程的男生"},{"title":"友链","date":"2022-03-22T04:16:57.039Z","updated":"2022-03-22T04:16:57.039Z","comments":false,"path":"links/index.html","permalink":"http://zouyc.cn/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-22T04:47:00.982Z","updated":"2022-03-22T04:47:00.982Z","comments":false,"path":"categories/index.html","permalink":"http://zouyc.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-22T04:15:03.778Z","updated":"2022-03-22T04:15:03.778Z","comments":false,"path":"tags/index.html","permalink":"http://zouyc.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring","slug":"Spring","date":"2022-03-23T10:48:23.000Z","updated":"2022-03-25T03:19:33.110Z","comments":true,"path":"2022/03/23/Spring/","link":"","permalink":"http://zouyc.cn/2022/03/23/Spring/","excerpt":"","text":"IoC容器 Spring为我们提供了一个容器，用于管理所有的JavaBean组件，这是Spring框架最核心的概念 举个例子来说明IoC容器到底是啥： 假设现在有一个MemberService和BookService，现在它俩都需要操作数据库，用传统方式自然是在每个Service中都创建数据源实例，比如： 1234public class MemberService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 1234public class BookService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 在每个Service中都需要重复创建这些对象，随着Service越来越多，难道我们要一个个手动创建出来吗？完全可以共享同一个DataSource，那IoC就是用来解决这些问题的，在Ioc模式下控制权发生了反转，所有的组件都由容器负责，而不是我们自己手动创建，最简单的方式就是通过XML文件来实现： 123456789101112131415&lt;beans&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt; &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;memberService&quot; class=&quot;MemberService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在这个文件中创建了三个JavaBean组件，可以发现两个Service共享同一个数据源ref=&quot;dataSource&quot;，创建好Bean之后就需要使用了Bean了 依赖注入方式： 注入在IoC容器中管理的Bean，可通过set()或构造方法实现 1234567public class BookService &#123; private DataSource dataSource; public setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125;&#125; 创建Spring项目 通过maven创建即可，需引入spring-context依赖 12345678910111213141516171819202122232425262728&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;spring-ioc-appcontext&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 一个特定的application.xml文件，就是之前组装Bean的文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 最后得告诉容器为我们创建并装配好所有得Bean，在主启动类中添加以下代码 12345678910public static void main(String[] args) &#123; // 在resources目录下加载配置文件，并完成Bean的创建 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 获取Bean MemberService member = context.getBean(MemberService.class); // 调用方法 member.login(&quot;username&quot;,&quot;password&quot;);&#125; 使用注解配置 其实完全可以不用XML文件配置Bean，使用注解配置更加简单 直接在类上添加@Component注解： 123@Componentpublic class MailService &#123;&#125; 12345@Componentpublic class UserService &#123; @Autowired private MailService mailService;&#125; @Component就等于在容器中定义了一个Bean，默认名为首字母小写，@Autowired就等于使用set()进行依赖注入 由于没有了配置文件，所以主启动类中的加载方式也有了变化 1234567@Configuration@ComponentScanpublic class AppConfig &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); &#125;&#125; @Configuration表示它是一个配置类，等于application.xml，@ComponentScan用于扫描当前类以及所在子包所有标注了@Component的类并将其创建，一定要严格按照这个包结构来创建类 Scope Spring容器创建的Bean默认都是单例的，所以说通过context.getBean()获取的Bean都是同一个实例，我们也可以让它每次都返回一个新的实例，把这种Bean称为原型，在类上下面的注解即可 1@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 注入List 通过定义接口和实现类，将所有该类型的Bean都注入到一个List中 12public interface Validator &#123;&#125; 123@Componentpublic class NameValidator implements Validator &#123;&#125; 123@Componentpublic class PasswordValidator implements Validator &#123;&#125; 12345@Componentpublic class Validators &#123; @Autowired List&lt;Validator&gt; validators;&#125; Validator接口有两个实现类，在Validators中定义好了集合的泛型，通过@Autowired就可将所有Validator类型的Bean注入到一个List中 第三方Bean 用于一个Bean不在我们的包管理之内 123456789@Configuration@ComponentScanpublic class AppConfig &#123; // 创建一个Bean: @Bean ZoneId createZoneId() &#123; return ZoneId.of(&quot;Z&quot;); &#125;&#125; @Bean只调用一次，它返回的Bean也是单例的 初始化和销毁 用于一个Bean在被注入后进行初始化操作以及容器关闭时进行销毁操作，需引入一个特定依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112@Componentpublic class MailService &#123; @PostConstruct public void init() &#123; System.out.println(&quot;init&quot;); &#125; @PreDestroy public void shutdown() &#123; System.out.println(&quot;shutdown&quot;); &#125;&#125; 在MailService被注入后就会执行init()，在容器关闭时执行shutdown()，需调用close() Resource Spring提供了一个org.springframework.core.io.Resource用于读取配置文件 12@Value(&quot;classpath:/logo.txt&quot;)private Resource resource; 还有更简单的方式，使用注解： 123456@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123; @Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId;&#125; $&#123;app.zone:Z&#125;表示如果Key不存在就用默认值Z 条件装配 当满足特定条件创建Bean，使用@Conditional，看一个简单例子： 123@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;&#125; 如果配置文件中有app.smtp并且值为true才创建 AOP 面向切面编程，可以将常用的比如日志，事务等从每个业务方法中抽离出来，本质其实是一个动态代理 引入AOP依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718@Aspect@Componentpublic class LoggingAspect &#123; // 在执行UserService的每个方法前执行: @Before(&quot;execution(public * com.zouyc.learn.service.UserService.*(..))&quot;) public void doAccessCheck() &#123; System.err.println(&quot;[Before] do access check...&quot;); &#125; // 在执行MailService的每个方法前后执行: @Around(&quot;execution(public * com.zouyc.learn.service.MailService.*(..))&quot;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123; System.err.println(&quot;[Around] start &quot; + pjp.getSignature()); Object retVal = pjp.proceed(); System.err.println(&quot;[Around] done &quot; + pjp.getSignature()); return retVal; &#125;&#125; 通过注解加特定的语法实现在方法执行前后做些事情，pjp.proceed()执行MailService的方法，最后还需在配置类上开启@EnableAspectJAutoProxy 可以看到AspectJ的语法是非常复杂的，怎样更简洁呢？使用纯注解 自定义一个注解 12345@Target(METHOD)@Retention(RUNTIME)public @interface MetricTime &#123; String value();&#125; 在需要被监控的方法上添加注解 1234@MetricTime(&quot;register&quot;)public void register() &#123; System.out.println(&quot;registration success&quot;);&#125; 定义Aspect类 12345678@Aspect@Componentpublic class MetricAspect &#123; @Around(&quot;@annotation(metricTime)&quot;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123; return joinPoint.proceed(); &#125;&#125; @Around(&quot;@annotation(metricTime)&quot;)找到标注了@MetricTime的方法，需注意方法参数上的metricTime和@annotation(metricTime)必须一样 AOP避坑： 始终使用get()方法访问，而不直接访问字段 1234public String sendMail() &#123; ZoneId zoneId = userService.zoneId; System.out.println(zoneId); // null&#125; 上述代码会报空指针异常，为什么？ 原因在于成员变量的初始化，正常来说构造方法第一行总是调用super()，但是Spring通过CGLIB动态创建的代理类并未调用super()，因此从父类继承的成员变量以及自身的成员变量都没有初始化，如何解决？ 1234public String sendMail() &#123; // 不要直接访问UserService的字段: ZoneId zoneId = userService.getZoneId();&#125; 为什么调用getZoneId()就能解决呢？因为代理类会覆写getZoneId()，并将其交给原始实例，这样变量就得到了初始化，就不会报空指针异常了，最后一点，如果你的类有可能被代理，就不要编写public final方法，因为无法被覆写 访问数据库 Spring提供了一个JdbcTemplate让我们操作JDBC，所以我们只需实例化一个JdbcTemplate 基本使用方法： 创建配置文件jdbc.properties，这里使用的是HSQLDB，它可以以内存模式运行，适合测试 12345678910&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt; 123456# 数据库文件名为testdb:jdbc.url=jdbc:hsqldb:file:testdb# Hsqldb默认的用户名是sa，口令是空字符串:jdbc.username=sajdbc.password= 读取数据库配置文件并创建DataSource和JdbcTemplate 1234567891011121314151617181920212223242526272829@PropertySource(&quot;classpath:jdbc.properties&quot;)public class AppConfig &#123; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String jdbcUsername; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String jdbcPassword; @Bean DataSource createDataSource() &#123; HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setJdbcUrl(jdbcUrl); hikariConfig.setUsername(jdbcUsername); hikariConfig.setPassword(jdbcPassword); hikariConfig.addDataSourceProperty(&quot;autoCommit&quot;, &quot;true&quot;); hikariConfig.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;5&quot;); hikariConfig.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60&quot;); return new HikariDataSource(hikariConfig); &#125; @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 由于是在HSQLDB内存模式下工作的，所以我们还需要建立对应的表 123456789101112@AutowiredJdbcTemplate jdbcTemplate;@PostConstructpublic void init() &#123; jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS users (&quot; // + &quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot; // + &quot;email VARCHAR(100) NOT NULL, &quot; // + &quot;password VARCHAR(100) NOT NULL, &quot; // + &quot;name VARCHAR(100) NOT NULL, &quot; // + &quot;UNIQUE (email))&quot;);&#125; 在其他Service中注入JdbcTemplate即可 JdbcTemplate的用法： T execute(ConnectionCallback&lt;T&gt; action)：使用Jdbc的Connection T execute(String sql, PreparedStatementCallback&lt;T&gt; action)：使用Jdbc的PreparedStatement T queryForObject(String sql, @Nullable Object[] args, RowMapper&lt;T&gt; rowMapper)：RowMapper将ResultSet映射成一个JavaBean并返回，返回一行记录 List&lt;T&gt; query(String sql, @Nullable Object[] args, RowMapper&lt;T&gt; rowMapper)：返回多行记录 INSERT操作： 因为INSERT涉及到主键自增， 所以它比较特殊 12345678910111213141516171819202122public User register(String email, String password, String name) &#123; // 创建一个KeyHolder: KeyHolder holder = new GeneratedKeyHolder(); if (1 != jdbcTemplate.update( // 参数1:PreparedStatementCreator (conn) -&gt; &#123; // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS: var ps = conn.prepareStatement(&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, email); ps.setObject(2, password); ps.setObject(3, name); return ps; &#125;, // 参数2:KeyHolder holder) ) &#123; throw new RuntimeException(&quot;Insert failed.&quot;); &#125; // 从KeyHolder中获取返回的自增值: return new User(holder.getKey().longValue(), email, password, name);&#125; 声明式事务 Spring提供了一个PlatformTransactionManager来表示事务管理器，事务由TransactionStatus表示 12PlatformTransactionManager transactionManager = new DataSourceTransactionManager();TransactionStatus transaction = transactionManager.getTransaction(new DefaultTransactionDefinition()); 使用声明式事务： 1234567@EnableTransactionManagementpublic class AppConfig &#123; @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 在需要使用的方法上添加@Transactional，或者在类上添加（表示类中所有public方法都支持事务），事务的原理仍是AOP代理，所以开启事务之后就不必添加EnableAspectJAutoProxy，判断事务回滚，只需抛出RuntimeException，如果要针对某个异常回滚，就在注解上定义出来： 1@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;) 事务的传播： 默认级别为REQUIRED，看代码： 1234567@Transactionalpublic User register(String email, String password, String name) &#123; // 插入用户记录: User user = jdbcTemplate.insert(&quot;...&quot;); // 增加100积分: bonusService.addBonus(user.id, 100);&#125; 可以看到上述代码中register()开启了事务，但是在方法中又调用了另一个bonusService，bonusService没必要再创建新事务，事务的默认传播级别REQUIRED表示，如果当前有事务就自动加入当前事务，如果没有才创建新事务，所以register()方法的开始和结束就是整个事务的范围，当然除了REQUIRED还有其他传播级别，这里就不一一赘述了 DAO层 DAO即Data Access Object的缩写，就是专门用来和数据库打交道的层级，负责处理各种业务逻辑 Spring提供了JdbcDaoSupport简化数据库操作，它的核心就是持有一个JdbcTemplate 1234567891011121314151617181920212223public abstract class JdbcDaoSupport extends DaoSupport &#123; @Nullable private JdbcTemplate jdbcTemplate; /** * Set the JdbcTemplate for this DAO explicitly, * as an alternative to specifying a DataSource. */ public final void setJdbcTemplate(@Nullable JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; /** * Return the JdbcTemplate for this DAO, * pre-initialized with the DataSource or set explicitly. */ @Nullable public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 可以看到JdbcDaoSupport并没有自动注入JdbcTemplate，所以得自己注入 编写一个AbstractDao用于注入JdbcTemplate 12345678910public abstract class AbstractDao extends JdbcDaoSupport &#123; @Autowired private JdbcTemplate jdbcTemplate; @PostConstruct public void init() &#123; super.setJdbcTemplate(jdbcTemplate); &#125;&#125; 这样继承了AbstractDao的子类就可以直接调用getJdbcTemplate()获取JdbcTemplate 我们还可以把更多的常用方法都写到AbstractDao中，这里就需要用到泛型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class AbstractDao&lt;T&gt; extends JdbcDaoSupport &#123; private String table; private Class&lt;T&gt; entityClass; private RowMapper&lt;T&gt; rowMapper; @Autowired private JdbcTemplate jdbcTemplate; @PostConstruct public void init() &#123; super.setJdbcTemplate(jdbcTemplate); &#125; public AbstractDao() &#123; this.entityClass = getParameterizedType(); this.table = this.entityClass.getSimpleName().toLowerCase() + &quot;s&quot;; this.rowMapper = new BeanPropertyRowMapper&lt;&gt;(entityClass); &#125; public Class&lt;T&gt; getParameterizedType() &#123; Type type = this.getClass().getGenericSuperclass(); if (type instanceof ParameterizedType) &#123; ParameterizedType t = (ParameterizedType) type; Type[] types = t.getActualTypeArguments(); Type firstType = types[0]; return (Class&lt;T&gt;) firstType; &#125; return null; &#125; public T getById(long id) &#123; &#125; public List&lt;T&gt; getAll(int pageIndex) &#123; &#125; public void deleteById(long id) &#123; &#125; public Class&lt;T&gt; getEntityClass() &#123; return entityClass; &#125; public String getTable() &#123; return table; &#125;&#125; 集成MyBatis MyBatis是一款半自动ORM框架，只负责把ResultSet映射成JavaBean，SQL仍需自己编写 要使用它先要引入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 使用MyBatis的核心就是创建SqlSessionFactory 123456@BeanSqlSessionFactoryBean createSqlSessionFactoryBean(@Autowired DataSource dataSource) &#123; var sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean;&#125; 它可以直接使用声明式事务，创建事务管理和使用JDBC是一样的 定义Mapper接口，编写SQL语句： 1234public interface UserMapper &#123; @Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;) User getById(@Param(&quot;id&quot;) long id);&#125; 扫描并创建Mapper的实现类： 123@MapperScan(&quot;com.zouyc.learn.mapper&quot;)public class AppConfig &#123;&#125; 在业务逻辑中直接注入UserMapper即可 XML配置：为了更加灵活的编写SQL语句，就需要使用XML文件来做到，详情查看官方文档","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"}]},{"title":"泛型","slug":"泛型","date":"2022-03-22T06:53:39.000Z","updated":"2022-03-22T09:29:14.953Z","comments":true,"path":"2022/03/22/泛型/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"什么是泛型 泛型就是编写模板代码来适应类型，好处就是不必强制转型，通过编译器对类型进行检查 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 这就是泛型，集合限定了元素必须为String类型，否则报错 泛型接口 除了在集合中使用泛型，有许多接口也用到了泛型，比如 Comparable&lt;T&gt; 可以直接对String类型的数组进行排序，因为String实现了Comparable接口 1public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence 123String[] s = &#123;&quot;B&quot;, &quot;A&quot;, &quot;C&quot;&#125;;Arrays.sort(s);System.out.println(Arrays.toString(s)); 如何实习自定义类的排序呢？实现Comparable接口 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt;&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public int compareTo(Person o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试： 12345678910Person[] people = &#123;new Person(&quot;lucy&quot;, 21), new Person(&quot;mary&quot;, 19), new Person(&quot;Mali&quot;, 33)&#125;;System.out.println(&quot;排序前&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125;Arrays.sort(people);System.out.println(&quot;排序后&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125; 通过控制台输出就可以发现Person数组已经按照年龄进行了升序排序 编写泛型 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 注意静态方法不能使用&lt;T&gt;，应该与实例类型的泛型区分开： 123public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123; return new Pair&lt;K&gt;(first, last);&#125; 擦拭法 虚拟机对泛型是一无所知的，视所有泛型为Object，在需要转型的时候编译器会根据T类型自动为我们安全的强制转型 这就造成了使用泛型时一些的局限 不能是基本类型，因为Object无法持有基本类型 在获取class时因为擦拭法导致取到的对象是同一个对象 也无法判断泛型的类型 不能实例化泛型 可以借助Class&lt;T&gt;来实例化泛型对象 1234public Pair(Class&lt;T&gt; clazz) &#123; first = clazz.newInstance(); last = clazz.newInstance();&#125; 泛型继承 12345public class IntPair extends Pair&lt;Integer&gt; &#123; public IntPair(Integer first, Integer last) &#123; super(first, last); &#125;&#125; 子类获取父类的泛型类型： 12345678910public static void main(String[] args) &#123; Class&lt;IntPair&gt; clazz = IntPair.class; Type type = clazz.getGenericSuperclass(); // 获得带有泛型的父类 if (type instanceof ParameterizedType)&#123; // 判断是否为参数化类型，即泛型 ParameterizedType p = (ParameterizedType) type; Type[] types = p.getActualTypeArguments(); // 父类可能有多个泛型 Type firstType = types[0]; // 取第一个泛型 System.out.println(firstType.getTypeName()); &#125;&#125; extends 在平时的继承关系中Integer是Number的子类，但是在泛型中Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类 比如我们定义了一个方法，限定了传入的参数为Pair&lt;Number&gt;类型，如果传入Pair&lt;Integer&gt;就会报错 123static int add(Pair&lt;Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 1234public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p);&#125; 那如何传入Integer呢？这就需要用到extends通配符来解决了，改造一下那个方法 123static int add(Pair&lt;? extends Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 这种通配符被称为上界通配符，把泛型类型T的上界限定在了Number 使用extends须知： 在add()中是不能获取Integer的引用的，下面代码是无法通过编译的，要求你强制转型 1Integer first = p.getFirst(); 因为我们虽然限定了泛型的上界为Number，但是传入的具体类型到底是Integer还是其他Number的子类是不知道的，编译器只能确定一定是Number的子类 也无法传递Number的子类型给对象的set() 1p.setFirst(new Integer(p.getFirst().intValue() + 100)); 总结一下： 允许调用get()获取Number的引用 不允许调用set(? extends Number)传入任何Number的引用 super 正好和Number相反，传入的是Integer以及它的父类 1Pair&lt;? super Integer&gt; p 使用super须知： 1234567public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p,5);&#125;static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; p.setFirst(n);&#125; 这段代码是可以被正常编译的，因为限定了下界为Integer，无论传入Integer还是它的父类都是可以的 但是无法使用Integer接收get()的返回值，因为无法确定具体返回的是Integer还是它的父类，唯一可以接收的是Object 123static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; Object first = p.getFirst();&#125; 所以对比extends和super可以发现： &lt;? extends Number&gt;可读不可写 &lt;? super Integer&gt;可写不可读 补充 声明泛型数组时，不能用new操作符创建数组，需强制转型 1Pair&lt;Integer&gt;[] pairs = (Pair&lt;Integer&gt;[]) new Pair[2];","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2022-03-22T05:59:45.000Z","updated":"2022-03-22T12:19:53.883Z","comments":true,"path":"2022/03/22/函数式编程/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FunctionalInterface 我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口： 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 支持函数式编程的都可以使用Lambda表达式 Lambda表达式 当我们用Arrays.sort()排序时，可以传入一个Comparator实例，并采用匿名类的方式来实现： 123456String[] array = ...Arrays.sort(array, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); 但是这种写法还是挺繁琐的，所以从JDK8开始，我们可以用Lambda表达式来替代这种繁琐的写法： 1234String[] array = ...Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2);&#125;); 使用Lambda只需要写出方法的定义，参数类型可以省略，编译器会自动推断出String类型，-&gt; &#123; ... &#125;表示方法体，如果只有一行return代码，还可以更加简洁： 1Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2)); 返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。 方法引用 除了使用Lambda之外，还可以直接传入方法引用： 123456789public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(&quot;, &quot;, array));&#125;static int cmp(String s1, String s2) &#123; return s1.compareTo(s2);&#125; 上面的代码是啥意思？可以看到Arrays.sort需传入一个数组和Comparator接口，在Comparator中有个方法int compare(T o1, T o2)，我们自己定义的方法cmp和compare这个方法的方法签名一致，即方法参数和返回类型相同，就可以直接使用方法引用，再看一个例子： 12345public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, String::compareTo); System.out.println(String.join(&quot;, &quot;, array));&#125; 查看String的compareTo方法发现参数只有一个，但是前面不是说方法签名要一致吗，这又是怎么回事？因为之前的方法是个静态方法，这里是一个实例方法，实例方法第一个隐含参数总是传入this，相当于： 1public static int compareTo(this, String o); 所以String::compareTo和compare方法签名是一致的 Stream 一个全新的流失API，可以存储有限或无限个元素，Stream是惰性计算，计算通常时发生在最后结果的获取，因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果： 如何创建一个Stream? Stream.of 1Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;); 数组或Collection 12Stream&lt;String&gt; stream = Arrays.stream(new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;);Stream&lt;String&gt; stream1 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).stream(); Supplier 通过Stream.generate()需传入Supplier对象 12345public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);&#125; Supplier是一个函数式接口，我们可以自己实现这个接口 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 123456789class NatualSupplier implements Supplier&lt;Integer&gt; &#123; int n = 0; @Override public Integer get() &#123; return n++; &#125;&#125; 基于Supplier创建的Stream会不断调用get()产生下一个元素，可以用来表示无限序列 1234public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.generate(new NatualSupplier()); stream.limit(20).forEach(System.out::println);&#125; 因为它会不断调用get()，我们必须设定一个界限stream.limit(20) 基本类型 因为Java的泛型不支持基本类型的，只能用Integer等包装类型，但是Stream会对频繁的拆箱装箱，所以为了提高效率，Java标准库给我们提供了三种使用基本类型的Stream -&gt; IntStream、LongStream、DoubleStream map Stream.map()是一个转换方法，将一个Stream转为另一个Stream 12Stream&lt;Integer&gt; stream = List.of(1, 2, 3).stream();Stream&lt;Integer&gt; streamMap = stream.map(item -&gt; item * item); 我们看看map()，最终会返回一个新结果的Stream 1234567891011121314/** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;, * &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); Stream.map()传入的是函数式接口Function，apply()最终return计算的结果 123456789101112@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); ...&#125; filter Stream.filter()是Stream的另一个常用转换方法 filter即过滤，过滤掉不满足条件的元素，满足条件的构成一个新的Stream 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Stream&lt;Integer&gt; streamMap = stream.filter(item -&gt; item % 2 == 0); filter接收Predicate，test()过滤掉不满足条件的元素 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t);&#125; reduce 是Stream的一个聚合方法，把一个Stream的所有元素按照聚合函数聚合成一个结果 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Integer reduce = stream.reduce(0, (acc, n) -&gt; acc + n); Stream.reduce()接收BinaryOperator，而它又继承自BiFunction，在BiFunction中有R apply(T t, U u) 12345678/** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */R apply(T t, U u); 所以BinaryOperator实际上是重写了父接口的方法apply()，通过这个方法进行累加计算 第一个参数0相当于初始值，见源码注释： 123456* &lt;pre&gt;&#123;@code* T result = identity;* for (T element : this stream)* result = accumulator.apply(result, element)* return result;* &#125;&lt;/pre&gt; 输出Stream 对Stream做map()或filter()操作时是不会进行任何计算的，reduce会立即得出结果 如何把进行了转换操作的元素保存下来呢？ 输出为集合： collect()并传入Collectors.toList()对象： 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();List&lt;Integer&gt; list = stream.map(n -&gt; n * n).collect(Collectors.toList()); 输出为数组： 12Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;).stream();String[] array = stream.toArray(String[]::new); 输出为Map： 12345678Stream&lt;String&gt; stream = List.of(&quot;Apple:Banana&quot;, &quot;Pear:Peach&quot;).stream();Map&lt;String, String&gt; map = stream.collect(Collectors .toMap( // 映射为key s -&gt; s.substring(0, s.indexOf(&#x27;:&#x27;)), // 映射为value s -&gt; s.substring(s.indexOf(&#x27;:&#x27;) + 1) )); 分组输出： 123Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Blackberry&quot;, &quot;Coconut&quot;, &quot;Avocado&quot;, &quot;Cherry&quot;, &quot;Apricots&quot;).stream();Map&lt;String, List&lt;String&gt;&gt; groups = stream.collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList())); 上述代码中Collectors.groupingBy以元素的首字母为依据做一个分组","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]}