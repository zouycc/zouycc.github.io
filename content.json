{"meta":{"title":"Ahser's Blog","subtitle":"","description":"","author":"John Doe","url":"http://zouyc.cn","root":"/"},"pages":[{"title":"关于我","date":"2022-03-22T05:10:18.878Z","updated":"2022-03-22T05:10:18.878Z","comments":false,"path":"about/index.html","permalink":"http://zouyc.cn/about/index.html","excerpt":"","text":"一个热爱计算机，热爱编程的男生"},{"title":"友链","date":"2022-03-22T04:16:57.039Z","updated":"2022-03-22T04:16:57.039Z","comments":false,"path":"links/index.html","permalink":"http://zouyc.cn/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-22T04:47:00.982Z","updated":"2022-03-22T04:47:00.982Z","comments":false,"path":"categories/index.html","permalink":"http://zouyc.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-22T04:15:03.778Z","updated":"2022-03-22T04:15:03.778Z","comments":false,"path":"tags/index.html","permalink":"http://zouyc.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JUC","slug":"JUC","date":"2022-04-04T08:44:41.000Z","updated":"2022-04-04T10:16:30.272Z","comments":true,"path":"2022/04/04/JUC/","link":"","permalink":"http://zouyc.cn/2022/04/04/JUC/","excerpt":"","text":"java.util.concurrent并发编程包，这个包下都是Java处理线程相关的类 虚假唤醒 多个线程中使用wait方法的时候应始终定义在while中，wait在哪里睡就在哪里醒，会继续往下判断，如果使用的是if只会执行一次 现在有四个线程，AB做加法，CD做减法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Test &#123; public static void main(String[] args) &#123; TestDemo testDemo = new TestDemo(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; testDemo.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; testDemo.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; testDemo.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;C&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; testDemo.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;D&quot;).start(); &#125;&#125;class TestDemo &#123; private int number = 0; public synchronized void incr() throws InterruptedException &#123; if (number != 0) &#123; this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot; : &quot; + number); this.notifyAll(); &#125; public synchronized void decr() throws InterruptedException &#123; if (number == 0) &#123; this.wait(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot; : &quot; + number); this.notifyAll(); &#125;&#125; 上面的代码会出现虚假唤醒的情况，我们来试着分析一下为什么？ 1234567假设：A获取锁执行++；A再次获取锁判断number！=0，这时候阻塞；C获取锁执行--；B获取锁执行++；A获取锁，从当前位置醒来继续往下执行，又对number进行了++操作，所以得到2... 为了解决这种情况的发生，我们应该在每次醒来时都进行判断，将if改为while即可： 123while (number != 0) &#123; this.wait();&#125; Lock实现案例 Lock跟synchronized的区别 →Lock是接口而synchronized是关键字，Lock有着比synchronized更广泛的锁的操作 1234567891011121314151617// 创建Lockprivate Lock lock = new ReentrantLock();private Condition condition = lock.newCondition();public void incr() throws InterruptedException &#123; lock.lock(); try &#123; while (number != 0) &#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot; : &quot; + number); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125;&#125; Condition它用来替代传统的Object的wait ()、notify ()实现线程间的协作，依赖于Lock接口，需注意：传统的wait方法会自动释放锁，而使用lock需手动释放 线程集合不安全 集合本身的方法上并没有synchronized 关键字，所以是不安全的，看源码： 12345public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1); this.elementData[this.size++] = var1; return true;&#125; 示例代码： 12345678List&lt;String&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;, String.valueOf(i)).start();&#125; 执行上面的代码会得到一个ConcurrentModificationException 异常，由于集合中的方法并不是同步的，所以在多个线程同时写的时候就会抛出异常，如何解决呢？ 方案一：使用Vector解决并发修改异常 1List&lt;String&gt; list = new Vector&lt;&gt;(); 方案二：使用Collections解决并发修改异常 1List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 方案三：使用CopyOnWriteArrayList解决并发修改异常 前面两种方法其实并不常用，一般都是通过写时复制技术来解决，那何为写时复制呢？ 集合在每次写的时候都会将元素复制一份出来，在新的集合中写，然后再合并，这样就实现了单写多读的操作 1List&lt;String&gt; list = new CopyOnWriteArrayList(); HashSet和HashMap线程不安全 跟集合一样，方法也没有synchronized关键字，也会得到并发修改异常，所以要通过写时复制技术来单写多读 HashSet: 12// 通过CopyOnWriteArraySet解决Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); HashMap: 12// 通过ConcurrentHashMap解决Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); 多线程锁 公平锁和非公平锁 公平锁：多个线程都能得到执行 非公平锁：谁先抢到谁就执行，其他线程不能执行 ReentrantLock 来配置公平锁或非公平锁： 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 可以看到源码中通过true或false来配置锁 可重入锁 synchronized和Lock都是可重入锁，可重入锁即可多次获得该锁 就比如我们回家，用钥匙开门之后就能随意进出房间了 123456789101112Object o = new Object();new Thread(() -&gt; &#123; synchronized (o) &#123; System.out.println(Thread.currentThread().getName() + &quot; 外层&quot;); synchronized (o) &#123; System.out.println(Thread.currentThread().getName() + &quot; 中层&quot;); synchronized (o) &#123; System.out.println(Thread.currentThread().getName() + &quot; 内层&quot;); &#125; &#125; &#125;&#125;, &quot;t1&quot;).start(); 123456789101112131415ReentrantLock lock = new ReentrantLock();new Thread(() -&gt; &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + &quot; 外层&quot;); try &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + &quot; 内层&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;, &quot;t1&quot;).start(); 死锁 两个或两个以上线程，因争夺资源造成互相等待的现象，需外力干涉来避免死锁 产生死锁的原因： 资源系统不足 进程运行推进顺序不合适 资源分配不当 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (a) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; waiting...&quot;); TimeUnit.SECONDS.sleep(2); synchronized (b) &#123; System.out.println(Thread.currentThread().getName() + &quot; get b&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;线程A&quot;).start(); new Thread(() -&gt; &#123; synchronized (b) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; waiting...&quot;); TimeUnit.SECONDS.sleep(2); synchronized (a) &#123; System.out.println(Thread.currentThread().getName() + &quot; get a&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;线程B&quot;).start();&#125; 两个线程都在尝试获取对方线程资源，就造成了死锁，这是通过代码输出来判断是否为死锁，JDK中有一个堆栈跟踪工具，可以通过命令查看是否为死锁 Callable Runnable接口缺失了一项功能，当线程终止时，无法获得线程返回的结果，为了支持此功能，Java中提供了Callable接口 这两个接口之间的区别主要是： 是否有返回值 是否抛出异常 实现方法名称不同，一个是run，一个是call 1234567class Demo implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;test callable...&quot;); return &quot;hello&quot;; &#125;&#125; 使用Callable 就不能直接用Thread来创建线程了，需要使用FutureTask 123FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new Demo());new Thread(task, &quot;callable&quot;).start();System.out.println(task.get()); // 获取call()中的返回值 强大的辅助类 CountDownLatch减少计数： 123456789101112131415161718public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(3); for (int i = 1; i &lt;= 3; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;号同学离开&quot;); // 计数器-1 countDownLatch.countDown(); &#125;, String.valueOf(i)).start(); &#125; // 当计数器没有变为0时就会一直等待 countDownLatch.await(); System.out.println(Thread.currentThread().getName() + &quot;班长锁门离开了&quot;); &#125;&#125; 班长总是在最后一个才离开，这就是CountDownLatch 的作用 CyclicBarrier循环栅栏 12345678910111213141516171819202122public class CyclicBarrierDemo &#123; private static final intNUMBER= 7; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER, () -&gt; &#123; System.out.println(&quot;恭喜你集齐七颗龙珠&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;颗龙珠&quot;); // 等待 cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 只有在集齐七颗龙珠后才会执行CyclicBarrier 中的方法 Semaphore信号灯 12345678910111213141516171819202122232425public class SemaphoreDemo &#123; public static void main(String[] args) &#123; // 设置许可数量，只有三个车位 Semaphore semaphore = new Semaphore(3); // 模拟六辆汽车 for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; try &#123; // 抢占车位 semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;号车抢到了车位&quot;); // 设置随机停车时间 TimeUnit.SECONDS.sleep(new Random().nextInt(5)); System.out.println(Thread.currentThread().getName() + &quot;号车离开了车位&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放车位 semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 用信号灯模拟停车的场景，只有三个车位，只有当某个车位的车离开了之后，其他的车才能抢占车位 读写锁 在多线程环境下对资源进行读写操作的时候，是可能会发生死锁的，需要用Java提供的读写锁来上锁和解锁，读写锁在读的时候是不能进行写操作的。 写锁：独占锁（一次只能一个线程进行写操作），读锁：共享锁（可多个线程进行读操作） 12345678910111213141516171819202122232425262728293031323334353637383940class Resource &#123; private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public void put(String key, Object value) &#123; // 添加写锁 lock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + &quot;正在写操作&quot; + key); try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; // 释放锁 lock.writeLock().unlock(); &#125; map.put(key, value); System.out.println(Thread.currentThread().getName() + &quot;写完了&quot; + key); &#125; public Object get(String key) &#123; // 添加读锁 lock.readLock().lock(); Object result = null; System.out.println(Thread.currentThread().getName() + &quot;正在读操作&quot; + key); try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.readLock().unlock(); &#125; result = map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读完了&quot; + key); return result; &#125;&#125; 锁降级： 读写锁在读的时候是不能进行写操作的。我们可以将写锁降为读锁，读锁不能升级为写锁 123456789101112131415161718public class DowngradeDemo &#123; public static void main(String[] args) &#123; ReadWriteLock lock = new ReentrantReadWriteLock(); Lock writeLock = lock.writeLock(); Lock readLock = lock.readLock(); // 锁降级 // 1.获取写锁 writeLock.lock(); System.out.println(&quot;write&quot;); // 2.获取读锁 readLock.lock(); System.out.println(&quot;read&quot;); // 3.释放写锁和读锁 writeLock.unlock(); readLock.unlock(); &#125;&#125; 阻塞队列 当队列为空时，获取元素将阻塞，直到插入新的元素，当队列满时，添加元素将阻塞 使用阻塞队列的好处就是，我们不需要关心什么时候阻塞线程，什么时候唤醒线程，这些操作都交给BlockingQueue来做 12345678// 创建阻塞队列BlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(3);queue.add(&quot;a&quot;)queue.add(&quot;b&quot;)queue.add(&quot;c&quot;)// Queue fullqueue.add(&quot;d&quot;) 线程池 一种线程使用模式，维护着多个线程，等待着监督管理，避免了频繁创建与销毁线程的代价，不仅能保证内核的充分利用，还能防止过分调度 线程池使用方式 通过Executors 工具类来创建线程 Executors.newFixedThreadPool()： 一池N线程 Executors.newSingleThreadExecutor()： 一池一线程 Executors.newCachedThreadPool()： 根据需求创建线程，可扩容 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 一池N线程 ExecutorService threadPool1 = Executors.newFixedThreadPool(5); // 一池一线程 ExecutorService threadPool2 = Executors.newSingleThreadExecutor(); // 一池可扩容线程 ExecutorService threadPool3 = Executors.newCachedThreadPool(); // 10个客户请求 for (int i = 1; i &lt;=10 ; i++) &#123; // 执行 threadPool3.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;正在办理业务&quot;); &#125;); &#125; threadPool3.shutdown(); &#125;&#125; 查看源码可以发现Executors调用的方法底层都使用了ThreadPoolExecutor 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造方法中有7个参数，分别是什么意思呢？ corePoolSize ：核心（常驻）的线程数量，比如一个银行有10个窗口，平时只开放5个窗口 maximumPoolSize：最大线程数量，就好比银行一共有10个窗口 keepAliveTime ：线程存活时间 unit ：搭配keepAliveTime 设置线程存活时间 workQueue ：阻塞队列 threadFactory ：用于创建线程 handler ：拒绝策略（多种） 线程池的工作流程和拒绝策略 上面的流程图即为线程池的工作流程：首先通过execute()来创建一个池子，核心线程数为2，如果要创建第三个线程，就会放到workQueue中等待，当workQueue满时就会创建新的线程直到 maximumPoolSize满，当maximumPoolSize满时就会执行拒绝策略。 JDK内置的拒绝策略： AbortPolicy ：抛出 RejectedExecutionException来拒绝新任务的处理。 CallerRunsPolicy ：“调用者运行”一种调节机制，该策略不会抛弃任务和异常，而是将某些任务回退到调用者，降低新任务的流量。 DiscardPolicy ：抛弃队列中等待最久的任务，然后把当前任务添加到队列中，尝试再次提交当前任务。 DiscardOldestPolicy ：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常，如果允许任务丢失，那这是最好的一种策略。 自定义线程 一般都是用自定义线程，在阿里巴巴开发手册中线程池不允许用Executors去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险。 123456789101112131415public class CustomThreadPoolDemo &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 2, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy()); // 10个客户请求 for (int i = 1; i &lt;=10 ; i++) &#123; // 执行 threadPoolExecutor.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;正在办理业务&quot;); &#125;); &#125; threadPoolExecutor.shutdown(); &#125;&#125; 分支合并框架（Fork/Join） 可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ForkJoinDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyTask task = new MyTask(1, 100); // 创建分支合并池对象 ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(task); // 获取最终合并之后的结果 System.out.println(submit.get()); forkJoinPool.shutdown(); &#125;&#125;class MyTask extends RecursiveTask&lt;Integer&gt; &#123; // 拆分时差值不能大于10 private static final Integer VALUE= 10; private int begin; private int end; private int result; public MyTask(int begin, int end) &#123; this.begin = begin; this.end = end; &#125; // 拆分和合并的过程 @Override protected Integer compute() &#123; if (end - begin &lt;=VALUE) &#123; // 相加 for (int i = begin; i &lt;= end; i++) &#123; result = result + i; &#125; &#125; else &#123; // 进一步做拆分 // 获取中间值 int middle = (begin + end) / 2; // 拆分左边 MyTask task1 = new MyTask(begin, middle); // 拆分右边 MyTask task2 = new MyTask(middle + 1, end); task1.fork(); task2.fork(); // 合并结果 result = task1.join() + task2.join(); &#125; return result; &#125;&#125; 异步回调 12345678910111213141516171819public class AsynchronousCallbackDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 异步调用，无返回值 CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;completableFuture1&quot;); &#125;); completableFuture1.get(); // 异步调用，有返回值 CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;completableFuture2&quot;); return 1024; &#125;); completableFuture2.whenComplete((result, exception) -&gt; &#123; System.out.println(&quot;--t--&quot; + result); // 方法返回值 System.out.println(&quot;--u--&quot; + exception); // 异常信息 &#125;).get(); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]},{"title":"MySQL索引和锁","slug":"MySQL索引和锁","date":"2022-04-04T07:34:11.000Z","updated":"2022-04-04T08:41:52.345Z","comments":true,"path":"2022/04/04/MySQL索引和锁/","link":"","permalink":"http://zouyc.cn/2022/04/04/MySQL%E7%B4%A2%E5%BC%95%E5%92%8C%E9%94%81/","excerpt":"","text":"索引 在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。 功能分类 普通索引： 最基本的索引，它没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。 主键索引：一种特殊的唯一索引，不允许有空值。一般在建表时同时创建主键索引。 组合索引：顾名思义，就是将单列索引进行组合。 外键索引：只有InnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。 全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支持全文索引。MEMORY引擎不支持。 结构分类 B+Tree索引 ：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索引类型。 Hash索引 : MySQL中Memory存储引擎默认支持的索引类型。 索引的操作 创建索引： 如果一个表中有一列是主键，那么就会默认为其创建主键索引 12345678910-- 标准语法CREATE [UNIQUE|FULLTEXT] INDEX 索引名称[USING 索引类型] -- 默认是B+TREEON 表名(列名...);-- 为student表中姓名列创建一个普通索引CREATE INDEX idx_name ON student(NAME);-- 为student表中年龄列创建一个唯一索引CREATE UNIQUE INDEX idx_age ON student(age); 查看索引： 12345-- 标准语法SHOW INDEX FROM 表名;-- 查看student表中的索引SHOW INDEX FROM student; 添加索引： 1234567891011121314151617-- 普通索引ALTER TABLE 表名 ADD INDEX 索引名称(列名);-- 组合索引ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);-- 主键索引ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); -- 外键索引(添加外键约束，就是外键索引)ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);-- 唯一索引ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);-- 全文索引(mysql只支持文本类型)ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名); 删除索引： 12345-- 标准语法DROP INDEX 索引名称 ON 表名;-- 删除student表中的idx_score索引DROP INDEX idx_score ON student; 索引的实现原则 索引是在MySQL的存储引擎中实现的，所以每种存储引擎的索引不一定完全相同，也不是所有的引擎支持所有的索引类型。这里我们主要介绍InnoDB引擎的实现的B+Tree索引。 B+Tree是一种树型数据结构，是B-Tree的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。我们逐步的来了解一下。 磁盘存储 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。 InnoDB引擎将若干个地址连接磁盘块，以此来达到页的大小16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。 BTree BTree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述BTree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。BTree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的BTree： 根据图中结构显示，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 查找顺序： 12345678模拟查找15的过程 : 1.根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字15在区间（&lt;17），找到磁盘块1的指针P1。2.P1指针找到磁盘块2，读入内存。【磁盘I/O操作第2次】 比较关键字15在区间（&gt;12），找到磁盘块2的指针P3。3.P3指针找到磁盘块7，读入内存。【磁盘I/O操作第3次】 在磁盘块7中找到关键字15。 B+Tree B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 B+Tree相对于BTree区别： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个连接指针。 数据记录都存放在叶子节点中。 将上一节中的BTree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算： 【有范围】对于主键的范围查找和分页查找 【有顺序】从根节点开始，进行随机查找 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。 总结 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 使用唯一索引，区分度越高，使用索引的效率越高。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 锁 当一个线程真正在操作数据的时候，其他线程只能等待。当一个线程执行完毕后，释放锁。其他线程才能进行操作！ 锁的分类 按操作分类： 共享锁：也叫读锁。针对同一份数据，多个事务读取操作可以同时加锁而不互相影响 ，但是不能修改数据记录。 排他锁：也叫写锁。加锁的数据，不能被其他事务加锁查询或修改 按粒度分类： 表级锁：操作时，会锁定整个表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低。偏向于MyISAM存储引擎！ 行级锁：操作时，会锁定当前操作行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。偏向于InnoDB存储引擎！ 页级锁：锁的粒度、发生冲突的概率和加锁的开销介于表锁和行锁之间，会出现死锁，并发性能一般。 按使用方式分类： 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据 存储引擎 表级锁 行级锁 页级锁 MyISAM 支持 不支持 不支持 InnoDB 支持 支持 不支持 MEMORY 支持 不支持 不支持 BDB 支持 不支持 支持 演示InnoDB锁 共享锁：数据可以被多个事务查询，但是不能修改 12-- 标准语法SELECT语句 LOCK IN SHARE MODE; 1234567891011-- 开启事务START TRANSACTION;-- 查询id为1的数据记录。加入共享锁SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;-- 查询分数为99分的数据记录。加入共享锁SELECT * FROM student WHERE score=99 LOCK IN SHARE MODE;-- 提交事务COMMIT; 1234567891011121314151617181920-- 开启事务START TRANSACTION;-- 查询id为1的数据记录(普通查询，可以查询)SELECT * FROM student WHERE id=1;-- 查询id为1的数据记录，并加入共享锁(可以查询。共享锁和共享锁兼容)SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;-- 修改id为1的姓名为张三三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)UPDATE student SET NAME=&#x27;张三三&#x27; WHERE id = 1;-- 修改id为2的姓名为李四四(修改成功，InnoDB引擎默认是行锁)UPDATE student SET NAME=&#x27;李四四&#x27; WHERE id = 2;-- 修改id为3的姓名为王五五(注意：InnoDB引擎如果不采用带索引的列。则会提升为表锁)UPDATE student SET NAME=&#x27;王五五&#x27; WHERE id = 3;-- 提交事务COMMIT; 排他锁：加锁的数据，不能被其他事务加锁查询或修改 12-- 标准语法SELECT语句 FOR UPDATE; 12345678-- 开启事务START TRANSACTION;-- 查询id为1的数据记录，并加入排他锁SELECT * FROM student WHERE id=1 FOR UPDATE;-- 提交事务COMMIT; 1234567891011121314151617-- 开启事务START TRANSACTION;-- 查询id为1的数据记录(普通查询没问题)SELECT * FROM student WHERE id=1;-- 查询id为1的数据记录，并加入共享锁(不能查询。因为排他锁不能和其他锁共存)SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;-- 查询id为1的数据记录，并加入排他锁(不能查询。因为排他锁不能和其他锁共存)SELECT * FROM student WHERE id=1 FOR UPDATE;-- 修改id为1的姓名为张三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功)UPDATE student SET NAME=&#x27;张三&#x27; WHERE id=1;-- 提交事务COMMIT; 悲观锁和乐观锁使用前提： 对于读的操作远多于写的操作的时候，这时候一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，这时候可以选择乐观锁。 如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险。这时候可以选择悲观锁。 总结 表锁和行锁 行锁：锁的粒度更细，加行锁的性能损耗较大。并发处理能力较高。InnoDB引擎默认支持！ 表锁：锁的粒度较粗，加表锁的性能损耗较小。并发处理能力较低。InnoDB、MyISAM引擎支持！ InnoDB锁优化建议 尽量通过带索引的列来完成数据查询，从而避免InnoDB无法加行锁而升级为表锁。 合理设计索引，索引要尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定。 尽可能减少基于范围的数据检索过滤条件。 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁的产生。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zouyc.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zouyc.cn/tags/MySQL/"}]},{"title":"Spring","slug":"Spring","date":"2022-03-23T10:48:23.000Z","updated":"2022-03-25T03:19:33.110Z","comments":true,"path":"2022/03/23/Spring/","link":"","permalink":"http://zouyc.cn/2022/03/23/Spring/","excerpt":"","text":"IoC容器 Spring为我们提供了一个容器，用于管理所有的JavaBean组件，这是Spring框架最核心的概念 举个例子来说明IoC容器到底是啥： 假设现在有一个MemberService和BookService，现在它俩都需要操作数据库，用传统方式自然是在每个Service中都创建数据源实例，比如： 1234public class MemberService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 1234public class BookService &#123; private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config);&#125; 在每个Service中都需要重复创建这些对象，随着Service越来越多，难道我们要一个个手动创建出来吗？完全可以共享同一个DataSource，那IoC就是用来解决这些问题的，在Ioc模式下控制权发生了反转，所有的组件都由容器负责，而不是我们自己手动创建，最简单的方式就是通过XML文件来实现： 123456789101112131415&lt;beans&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt; &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;memberService&quot; class=&quot;MemberService&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在这个文件中创建了三个JavaBean组件，可以发现两个Service共享同一个数据源ref=&quot;dataSource&quot;，创建好Bean之后就需要使用了Bean了 依赖注入方式： 注入在IoC容器中管理的Bean，可通过set()或构造方法实现 1234567public class BookService &#123; private DataSource dataSource; public setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125;&#125; 创建Spring项目 通过maven创建即可，需引入spring-context依赖 12345678910111213141516171819202122232425262728&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;spring-ioc-appcontext&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 一个特定的application.xml文件，就是之前组装Bean的文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 最后得告诉容器为我们创建并装配好所有得Bean，在主启动类中添加以下代码 12345678910public static void main(String[] args) &#123; // 在resources目录下加载配置文件，并完成Bean的创建 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 获取Bean MemberService member = context.getBean(MemberService.class); // 调用方法 member.login(&quot;username&quot;,&quot;password&quot;);&#125; 使用注解配置 其实完全可以不用XML文件配置Bean，使用注解配置更加简单 直接在类上添加@Component注解： 123@Componentpublic class MailService &#123;&#125; 12345@Componentpublic class UserService &#123; @Autowired private MailService mailService;&#125; @Component就等于在容器中定义了一个Bean，默认名为首字母小写，@Autowired就等于使用set()进行依赖注入 由于没有了配置文件，所以主启动类中的加载方式也有了变化 1234567@Configuration@ComponentScanpublic class AppConfig &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); &#125;&#125; @Configuration表示它是一个配置类，等于application.xml，@ComponentScan用于扫描当前类以及所在子包所有标注了@Component的类并将其创建，一定要严格按照这个包结构来创建类 Scope Spring容器创建的Bean默认都是单例的，所以说通过context.getBean()获取的Bean都是同一个实例，我们也可以让它每次都返回一个新的实例，把这种Bean称为原型，在类上下面的注解即可 1@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 注入List 通过定义接口和实现类，将所有该类型的Bean都注入到一个List中 12public interface Validator &#123;&#125; 123@Componentpublic class NameValidator implements Validator &#123;&#125; 123@Componentpublic class PasswordValidator implements Validator &#123;&#125; 12345@Componentpublic class Validators &#123; @Autowired List&lt;Validator&gt; validators;&#125; Validator接口有两个实现类，在Validators中定义好了集合的泛型，通过@Autowired就可将所有Validator类型的Bean注入到一个List中 第三方Bean 用于一个Bean不在我们的包管理之内 123456789@Configuration@ComponentScanpublic class AppConfig &#123; // 创建一个Bean: @Bean ZoneId createZoneId() &#123; return ZoneId.of(&quot;Z&quot;); &#125;&#125; @Bean只调用一次，它返回的Bean也是单例的 初始化和销毁 用于一个Bean在被注入后进行初始化操作以及容器关闭时进行销毁操作，需引入一个特定依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112@Componentpublic class MailService &#123; @PostConstruct public void init() &#123; System.out.println(&quot;init&quot;); &#125; @PreDestroy public void shutdown() &#123; System.out.println(&quot;shutdown&quot;); &#125;&#125; 在MailService被注入后就会执行init()，在容器关闭时执行shutdown()，需调用close() Resource Spring提供了一个org.springframework.core.io.Resource用于读取配置文件 12@Value(&quot;classpath:/logo.txt&quot;)private Resource resource; 还有更简单的方式，使用注解： 123456@PropertySource(&quot;app.properties&quot;) // 表示读取classpath的app.propertiespublic class AppConfig &#123; @Value(&quot;$&#123;app.zone:Z&#125;&quot;) String zoneId;&#125; $&#123;app.zone:Z&#125;表示如果Key不存在就用默认值Z 条件装配 当满足特定条件创建Bean，使用@Conditional，看一个简单例子： 123@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)public class MailService &#123;&#125; 如果配置文件中有app.smtp并且值为true才创建 AOP 面向切面编程，可以将常用的比如日志，事务等从每个业务方法中抽离出来，本质其实是一个动态代理 引入AOP依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718@Aspect@Componentpublic class LoggingAspect &#123; // 在执行UserService的每个方法前执行: @Before(&quot;execution(public * com.zouyc.learn.service.UserService.*(..))&quot;) public void doAccessCheck() &#123; System.err.println(&quot;[Before] do access check...&quot;); &#125; // 在执行MailService的每个方法前后执行: @Around(&quot;execution(public * com.zouyc.learn.service.MailService.*(..))&quot;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable &#123; System.err.println(&quot;[Around] start &quot; + pjp.getSignature()); Object retVal = pjp.proceed(); System.err.println(&quot;[Around] done &quot; + pjp.getSignature()); return retVal; &#125;&#125; 通过注解加特定的语法实现在方法执行前后做些事情，pjp.proceed()执行MailService的方法，最后还需在配置类上开启@EnableAspectJAutoProxy 可以看到AspectJ的语法是非常复杂的，怎样更简洁呢？使用纯注解 自定义一个注解 12345@Target(METHOD)@Retention(RUNTIME)public @interface MetricTime &#123; String value();&#125; 在需要被监控的方法上添加注解 1234@MetricTime(&quot;register&quot;)public void register() &#123; System.out.println(&quot;registration success&quot;);&#125; 定义Aspect类 12345678@Aspect@Componentpublic class MetricAspect &#123; @Around(&quot;@annotation(metricTime)&quot;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123; return joinPoint.proceed(); &#125;&#125; @Around(&quot;@annotation(metricTime)&quot;)找到标注了@MetricTime的方法，需注意方法参数上的metricTime和@annotation(metricTime)必须一样 AOP避坑： 始终使用get()方法访问，而不直接访问字段 1234public String sendMail() &#123; ZoneId zoneId = userService.zoneId; System.out.println(zoneId); // null&#125; 上述代码会报空指针异常，为什么？ 原因在于成员变量的初始化，正常来说构造方法第一行总是调用super()，但是Spring通过CGLIB动态创建的代理类并未调用super()，因此从父类继承的成员变量以及自身的成员变量都没有初始化，如何解决？ 1234public String sendMail() &#123; // 不要直接访问UserService的字段: ZoneId zoneId = userService.getZoneId();&#125; 为什么调用getZoneId()就能解决呢？因为代理类会覆写getZoneId()，并将其交给原始实例，这样变量就得到了初始化，就不会报空指针异常了，最后一点，如果你的类有可能被代理，就不要编写public final方法，因为无法被覆写 访问数据库 Spring提供了一个JdbcTemplate让我们操作JDBC，所以我们只需实例化一个JdbcTemplate 基本使用方法： 创建配置文件jdbc.properties，这里使用的是HSQLDB，它可以以内存模式运行，适合测试 12345678910&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt; 123456# 数据库文件名为testdb:jdbc.url=jdbc:hsqldb:file:testdb# Hsqldb默认的用户名是sa，口令是空字符串:jdbc.username=sajdbc.password= 读取数据库配置文件并创建DataSource和JdbcTemplate 1234567891011121314151617181920212223242526272829@PropertySource(&quot;classpath:jdbc.properties&quot;)public class AppConfig &#123; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String jdbcUsername; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String jdbcPassword; @Bean DataSource createDataSource() &#123; HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setJdbcUrl(jdbcUrl); hikariConfig.setUsername(jdbcUsername); hikariConfig.setPassword(jdbcPassword); hikariConfig.addDataSourceProperty(&quot;autoCommit&quot;, &quot;true&quot;); hikariConfig.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;5&quot;); hikariConfig.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60&quot;); return new HikariDataSource(hikariConfig); &#125; @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 由于是在HSQLDB内存模式下工作的，所以我们还需要建立对应的表 123456789101112@AutowiredJdbcTemplate jdbcTemplate;@PostConstructpublic void init() &#123; jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS users (&quot; // + &quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot; // + &quot;email VARCHAR(100) NOT NULL, &quot; // + &quot;password VARCHAR(100) NOT NULL, &quot; // + &quot;name VARCHAR(100) NOT NULL, &quot; // + &quot;UNIQUE (email))&quot;);&#125; 在其他Service中注入JdbcTemplate即可 JdbcTemplate的用法： T execute(ConnectionCallback&lt;T&gt; action)：使用Jdbc的Connection T execute(String sql, PreparedStatementCallback&lt;T&gt; action)：使用Jdbc的PreparedStatement T queryForObject(String sql, @Nullable Object[] args, RowMapper&lt;T&gt; rowMapper)：RowMapper将ResultSet映射成一个JavaBean并返回，返回一行记录 List&lt;T&gt; query(String sql, @Nullable Object[] args, RowMapper&lt;T&gt; rowMapper)：返回多行记录 INSERT操作： 因为INSERT涉及到主键自增， 所以它比较特殊 12345678910111213141516171819202122public User register(String email, String password, String name) &#123; // 创建一个KeyHolder: KeyHolder holder = new GeneratedKeyHolder(); if (1 != jdbcTemplate.update( // 参数1:PreparedStatementCreator (conn) -&gt; &#123; // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS: var ps = conn.prepareStatement(&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, email); ps.setObject(2, password); ps.setObject(3, name); return ps; &#125;, // 参数2:KeyHolder holder) ) &#123; throw new RuntimeException(&quot;Insert failed.&quot;); &#125; // 从KeyHolder中获取返回的自增值: return new User(holder.getKey().longValue(), email, password, name);&#125; 声明式事务 Spring提供了一个PlatformTransactionManager来表示事务管理器，事务由TransactionStatus表示 12PlatformTransactionManager transactionManager = new DataSourceTransactionManager();TransactionStatus transaction = transactionManager.getTransaction(new DefaultTransactionDefinition()); 使用声明式事务： 1234567@EnableTransactionManagementpublic class AppConfig &#123; @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 在需要使用的方法上添加@Transactional，或者在类上添加（表示类中所有public方法都支持事务），事务的原理仍是AOP代理，所以开启事务之后就不必添加EnableAspectJAutoProxy，判断事务回滚，只需抛出RuntimeException，如果要针对某个异常回滚，就在注解上定义出来： 1@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;) 事务的传播： 默认级别为REQUIRED，看代码： 1234567@Transactionalpublic User register(String email, String password, String name) &#123; // 插入用户记录: User user = jdbcTemplate.insert(&quot;...&quot;); // 增加100积分: bonusService.addBonus(user.id, 100);&#125; 可以看到上述代码中register()开启了事务，但是在方法中又调用了另一个bonusService，bonusService没必要再创建新事务，事务的默认传播级别REQUIRED表示，如果当前有事务就自动加入当前事务，如果没有才创建新事务，所以register()方法的开始和结束就是整个事务的范围，当然除了REQUIRED还有其他传播级别，这里就不一一赘述了 DAO层 DAO即Data Access Object的缩写，就是专门用来和数据库打交道的层级，负责处理各种业务逻辑 Spring提供了JdbcDaoSupport简化数据库操作，它的核心就是持有一个JdbcTemplate 1234567891011121314151617181920212223public abstract class JdbcDaoSupport extends DaoSupport &#123; @Nullable private JdbcTemplate jdbcTemplate; /** * Set the JdbcTemplate for this DAO explicitly, * as an alternative to specifying a DataSource. */ public final void setJdbcTemplate(@Nullable JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; /** * Return the JdbcTemplate for this DAO, * pre-initialized with the DataSource or set explicitly. */ @Nullable public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 可以看到JdbcDaoSupport并没有自动注入JdbcTemplate，所以得自己注入 编写一个AbstractDao用于注入JdbcTemplate 12345678910public abstract class AbstractDao extends JdbcDaoSupport &#123; @Autowired private JdbcTemplate jdbcTemplate; @PostConstruct public void init() &#123; super.setJdbcTemplate(jdbcTemplate); &#125;&#125; 这样继承了AbstractDao的子类就可以直接调用getJdbcTemplate()获取JdbcTemplate 我们还可以把更多的常用方法都写到AbstractDao中，这里就需要用到泛型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class AbstractDao&lt;T&gt; extends JdbcDaoSupport &#123; private String table; private Class&lt;T&gt; entityClass; private RowMapper&lt;T&gt; rowMapper; @Autowired private JdbcTemplate jdbcTemplate; @PostConstruct public void init() &#123; super.setJdbcTemplate(jdbcTemplate); &#125; public AbstractDao() &#123; this.entityClass = getParameterizedType(); this.table = this.entityClass.getSimpleName().toLowerCase() + &quot;s&quot;; this.rowMapper = new BeanPropertyRowMapper&lt;&gt;(entityClass); &#125; public Class&lt;T&gt; getParameterizedType() &#123; Type type = this.getClass().getGenericSuperclass(); if (type instanceof ParameterizedType) &#123; ParameterizedType t = (ParameterizedType) type; Type[] types = t.getActualTypeArguments(); Type firstType = types[0]; return (Class&lt;T&gt;) firstType; &#125; return null; &#125; public T getById(long id) &#123; &#125; public List&lt;T&gt; getAll(int pageIndex) &#123; &#125; public void deleteById(long id) &#123; &#125; public Class&lt;T&gt; getEntityClass() &#123; return entityClass; &#125; public String getTable() &#123; return table; &#125;&#125; 集成MyBatis MyBatis是一款半自动ORM框架，只负责把ResultSet映射成JavaBean，SQL仍需自己编写 要使用它先要引入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 使用MyBatis的核心就是创建SqlSessionFactory 123456@BeanSqlSessionFactoryBean createSqlSessionFactoryBean(@Autowired DataSource dataSource) &#123; var sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean;&#125; 它可以直接使用声明式事务，创建事务管理和使用JDBC是一样的 定义Mapper接口，编写SQL语句： 1234public interface UserMapper &#123; @Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;) User getById(@Param(&quot;id&quot;) long id);&#125; 扫描并创建Mapper的实现类： 123@MapperScan(&quot;com.zouyc.learn.mapper&quot;)public class AppConfig &#123;&#125; 在业务逻辑中直接注入UserMapper即可 XML配置：为了更加灵活的编写SQL语句，就需要使用XML文件来做到，详情查看官方文档","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"}]},{"title":"泛型","slug":"泛型","date":"2022-03-22T06:53:39.000Z","updated":"2022-03-22T09:29:14.953Z","comments":true,"path":"2022/03/22/泛型/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"什么是泛型 泛型就是编写模板代码来适应类型，好处就是不必强制转型，通过编译器对类型进行检查 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 这就是泛型，集合限定了元素必须为String类型，否则报错 泛型接口 除了在集合中使用泛型，有许多接口也用到了泛型，比如 Comparable&lt;T&gt; 可以直接对String类型的数组进行排序，因为String实现了Comparable接口 1public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence 123String[] s = &#123;&quot;B&quot;, &quot;A&quot;, &quot;C&quot;&#125;;Arrays.sort(s);System.out.println(Arrays.toString(s)); 如何实习自定义类的排序呢？实现Comparable接口 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt;&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public int compareTo(Person o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试： 12345678910Person[] people = &#123;new Person(&quot;lucy&quot;, 21), new Person(&quot;mary&quot;, 19), new Person(&quot;Mali&quot;, 33)&#125;;System.out.println(&quot;排序前&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125;Arrays.sort(people);System.out.println(&quot;排序后&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125; 通过控制台输出就可以发现Person数组已经按照年龄进行了升序排序 编写泛型 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 注意静态方法不能使用&lt;T&gt;，应该与实例类型的泛型区分开： 123public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123; return new Pair&lt;K&gt;(first, last);&#125; 擦拭法 虚拟机对泛型是一无所知的，视所有泛型为Object，在需要转型的时候编译器会根据T类型自动为我们安全的强制转型 这就造成了使用泛型时一些的局限 不能是基本类型，因为Object无法持有基本类型 在获取class时因为擦拭法导致取到的对象是同一个对象 也无法判断泛型的类型 不能实例化泛型 可以借助Class&lt;T&gt;来实例化泛型对象 1234public Pair(Class&lt;T&gt; clazz) &#123; first = clazz.newInstance(); last = clazz.newInstance();&#125; 泛型继承 12345public class IntPair extends Pair&lt;Integer&gt; &#123; public IntPair(Integer first, Integer last) &#123; super(first, last); &#125;&#125; 子类获取父类的泛型类型： 12345678910public static void main(String[] args) &#123; Class&lt;IntPair&gt; clazz = IntPair.class; Type type = clazz.getGenericSuperclass(); // 获得带有泛型的父类 if (type instanceof ParameterizedType)&#123; // 判断是否为参数化类型，即泛型 ParameterizedType p = (ParameterizedType) type; Type[] types = p.getActualTypeArguments(); // 父类可能有多个泛型 Type firstType = types[0]; // 取第一个泛型 System.out.println(firstType.getTypeName()); &#125;&#125; extends 在平时的继承关系中Integer是Number的子类，但是在泛型中Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类 比如我们定义了一个方法，限定了传入的参数为Pair&lt;Number&gt;类型，如果传入Pair&lt;Integer&gt;就会报错 123static int add(Pair&lt;Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 1234public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p);&#125; 那如何传入Integer呢？这就需要用到extends通配符来解决了，改造一下那个方法 123static int add(Pair&lt;? extends Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 这种通配符被称为上界通配符，把泛型类型T的上界限定在了Number 使用extends须知： 在add()中是不能获取Integer的引用的，下面代码是无法通过编译的，要求你强制转型 1Integer first = p.getFirst(); 因为我们虽然限定了泛型的上界为Number，但是传入的具体类型到底是Integer还是其他Number的子类是不知道的，编译器只能确定一定是Number的子类 也无法传递Number的子类型给对象的set() 1p.setFirst(new Integer(p.getFirst().intValue() + 100)); 总结一下： 允许调用get()获取Number的引用 不允许调用set(? extends Number)传入任何Number的引用 super 正好和Number相反，传入的是Integer以及它的父类 1Pair&lt;? super Integer&gt; p 使用super须知： 1234567public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p,5);&#125;static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; p.setFirst(n);&#125; 这段代码是可以被正常编译的，因为限定了下界为Integer，无论传入Integer还是它的父类都是可以的 但是无法使用Integer接收get()的返回值，因为无法确定具体返回的是Integer还是它的父类，唯一可以接收的是Object 123static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; Object first = p.getFirst();&#125; 所以对比extends和super可以发现： &lt;? extends Number&gt;可读不可写 &lt;? super Integer&gt;可写不可读 补充 声明泛型数组时，不能用new操作符创建数组，需强制转型 1Pair&lt;Integer&gt;[] pairs = (Pair&lt;Integer&gt;[]) new Pair[2];","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2022-03-22T05:59:45.000Z","updated":"2022-03-22T12:19:53.883Z","comments":true,"path":"2022/03/22/函数式编程/","link":"","permalink":"http://zouyc.cn/2022/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FunctionalInterface 我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口： 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 支持函数式编程的都可以使用Lambda表达式 Lambda表达式 当我们用Arrays.sort()排序时，可以传入一个Comparator实例，并采用匿名类的方式来实现： 123456String[] array = ...Arrays.sort(array, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); 但是这种写法还是挺繁琐的，所以从JDK8开始，我们可以用Lambda表达式来替代这种繁琐的写法： 1234String[] array = ...Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2);&#125;); 使用Lambda只需要写出方法的定义，参数类型可以省略，编译器会自动推断出String类型，-&gt; &#123; ... &#125;表示方法体，如果只有一行return代码，还可以更加简洁： 1Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2)); 返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。 方法引用 除了使用Lambda之外，还可以直接传入方法引用： 123456789public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(&quot;, &quot;, array));&#125;static int cmp(String s1, String s2) &#123; return s1.compareTo(s2);&#125; 上面的代码是啥意思？可以看到Arrays.sort需传入一个数组和Comparator接口，在Comparator中有个方法int compare(T o1, T o2)，我们自己定义的方法cmp和compare这个方法的方法签名一致，即方法参数和返回类型相同，就可以直接使用方法引用，再看一个例子： 12345public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, String::compareTo); System.out.println(String.join(&quot;, &quot;, array));&#125; 查看String的compareTo方法发现参数只有一个，但是前面不是说方法签名要一致吗，这又是怎么回事？因为之前的方法是个静态方法，这里是一个实例方法，实例方法第一个隐含参数总是传入this，相当于： 1public static int compareTo(this, String o); 所以String::compareTo和compare方法签名是一致的 Stream 一个全新的流失API，可以存储有限或无限个元素，Stream是惰性计算，计算通常时发生在最后结果的获取，因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果： 如何创建一个Stream? Stream.of 1Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;); 数组或Collection 12Stream&lt;String&gt; stream = Arrays.stream(new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;);Stream&lt;String&gt; stream1 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).stream(); Supplier 通过Stream.generate()需传入Supplier对象 12345public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);&#125; Supplier是一个函数式接口，我们可以自己实现这个接口 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 123456789class NatualSupplier implements Supplier&lt;Integer&gt; &#123; int n = 0; @Override public Integer get() &#123; return n++; &#125;&#125; 基于Supplier创建的Stream会不断调用get()产生下一个元素，可以用来表示无限序列 1234public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.generate(new NatualSupplier()); stream.limit(20).forEach(System.out::println);&#125; 因为它会不断调用get()，我们必须设定一个界限stream.limit(20) 基本类型 因为Java的泛型不支持基本类型的，只能用Integer等包装类型，但是Stream会对频繁的拆箱装箱，所以为了提高效率，Java标准库给我们提供了三种使用基本类型的Stream -&gt; IntStream、LongStream、DoubleStream map Stream.map()是一个转换方法，将一个Stream转为另一个Stream 12Stream&lt;Integer&gt; stream = List.of(1, 2, 3).stream();Stream&lt;Integer&gt; streamMap = stream.map(item -&gt; item * item); 我们看看map()，最终会返回一个新结果的Stream 1234567891011121314/** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;, * &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); Stream.map()传入的是函数式接口Function，apply()最终return计算的结果 123456789101112@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); ...&#125; filter Stream.filter()是Stream的另一个常用转换方法 filter即过滤，过滤掉不满足条件的元素，满足条件的构成一个新的Stream 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Stream&lt;Integer&gt; streamMap = stream.filter(item -&gt; item % 2 == 0); filter接收Predicate，test()过滤掉不满足条件的元素 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t);&#125; reduce 是Stream的一个聚合方法，把一个Stream的所有元素按照聚合函数聚合成一个结果 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Integer reduce = stream.reduce(0, (acc, n) -&gt; acc + n); Stream.reduce()接收BinaryOperator，而它又继承自BiFunction，在BiFunction中有R apply(T t, U u) 12345678/** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */R apply(T t, U u); 所以BinaryOperator实际上是重写了父接口的方法apply()，通过这个方法进行累加计算 第一个参数0相当于初始值，见源码注释： 123456* &lt;pre&gt;&#123;@code* T result = identity;* for (T element : this stream)* result = accumulator.apply(result, element)* return result;* &#125;&lt;/pre&gt; 输出Stream 对Stream做map()或filter()操作时是不会进行任何计算的，reduce会立即得出结果 如何把进行了转换操作的元素保存下来呢？ 输出为集合： collect()并传入Collectors.toList()对象： 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();List&lt;Integer&gt; list = stream.map(n -&gt; n * n).collect(Collectors.toList()); 输出为数组： 12Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;).stream();String[] array = stream.toArray(String[]::new); 输出为Map： 12345678Stream&lt;String&gt; stream = List.of(&quot;Apple:Banana&quot;, &quot;Pear:Peach&quot;).stream();Map&lt;String, String&gt; map = stream.collect(Collectors .toMap( // 映射为key s -&gt; s.substring(0, s.indexOf(&#x27;:&#x27;)), // 映射为value s -&gt; s.substring(s.indexOf(&#x27;:&#x27;) + 1) )); 分组输出： 123Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Blackberry&quot;, &quot;Coconut&quot;, &quot;Avocado&quot;, &quot;Cherry&quot;, &quot;Apricots&quot;).stream();Map&lt;String, List&lt;String&gt;&gt; groups = stream.collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList())); 上述代码中Collectors.groupingBy以元素的首字母为依据做一个分组","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.cn/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"http://zouyc.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.cn/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zouyc.cn/tags/MySQL/"},{"name":"Spring","slug":"Spring","permalink":"http://zouyc.cn/tags/Spring/"}]}