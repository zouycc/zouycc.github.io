{"meta":{"title":"Ahser's Blog","subtitle":"","description":"","author":"John Doe","url":"http://zouyc.xyz","root":"/"},"pages":[{"title":"关于我","date":"2022-03-22T05:10:18.878Z","updated":"2022-03-22T05:10:18.878Z","comments":false,"path":"about/index.html","permalink":"http://zouyc.xyz/about/index.html","excerpt":"","text":"一个热爱计算机，热爱编程的男生"},{"title":"标签","date":"2022-03-22T04:15:03.778Z","updated":"2022-03-22T04:15:03.778Z","comments":false,"path":"tags/index.html","permalink":"http://zouyc.xyz/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-03-22T04:16:57.039Z","updated":"2022-03-22T04:16:57.039Z","comments":false,"path":"links/index.html","permalink":"http://zouyc.xyz/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-22T04:47:00.982Z","updated":"2022-03-22T04:47:00.982Z","comments":false,"path":"categories/index.html","permalink":"http://zouyc.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"泛型","slug":"泛型","date":"2022-03-22T06:53:39.000Z","updated":"2022-03-22T09:29:14.953Z","comments":true,"path":"2022/03/22/泛型/","link":"","permalink":"http://zouyc.xyz/2022/03/22/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"什么是泛型 泛型就是编写模板代码来适应类型，好处就是不必强制转型，通过编译器对类型进行检查 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 这就是泛型，集合限定了元素必须为String类型，否则报错 泛型接口 除了在集合中使用泛型，有许多接口也用到了泛型，比如 Comparable&lt;T&gt; 可以直接对String类型的数组进行排序，因为String实现了Comparable接口 1public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence 123String[] s = &#123;&quot;B&quot;, &quot;A&quot;, &quot;C&quot;&#125;;Arrays.sort(s);System.out.println(Arrays.toString(s)); 如何实习自定义类的排序呢？实现Comparable接口 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt;&#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public int compareTo(Person o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试： 12345678910Person[] people = &#123;new Person(&quot;lucy&quot;, 21), new Person(&quot;mary&quot;, 19), new Person(&quot;Mali&quot;, 33)&#125;;System.out.println(&quot;排序前&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125;Arrays.sort(people);System.out.println(&quot;排序后&quot;);for (Person person : people) &#123; System.out.println(person.getName() + &quot; : &quot; + person.getAge());&#125; 通过控制台输出就可以发现Person数组已经按照年龄进行了升序排序 编写泛型 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; return first; &#125; public T getLast() &#123; return last; &#125;&#125; 注意静态方法不能使用&lt;T&gt;，应该与实例类型的泛型区分开： 123public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123; return new Pair&lt;K&gt;(first, last);&#125; 擦拭法 虚拟机对泛型是一无所知的，视所有泛型为Object，在需要转型的时候编译器会根据T类型自动为我们安全的强制转型 这就造成了使用泛型时一些的局限 不能是基本类型，因为Object无法持有基本类型 在获取class时因为擦拭法导致取到的对象是同一个对象 也无法判断泛型的类型 不能实例化泛型 可以借助Class&lt;T&gt;来实例化泛型对象 1234public Pair(Class&lt;T&gt; clazz) &#123; first = clazz.newInstance(); last = clazz.newInstance();&#125; 泛型继承 12345public class IntPair extends Pair&lt;Integer&gt; &#123; public IntPair(Integer first, Integer last) &#123; super(first, last); &#125;&#125; 子类获取父类的泛型类型： 12345678910public static void main(String[] args) &#123; Class&lt;IntPair&gt; clazz = IntPair.class; Type type = clazz.getGenericSuperclass(); // 获得带有泛型的父类 if (type instanceof ParameterizedType)&#123; // 判断是否为参数化类型，即泛型 ParameterizedType p = (ParameterizedType) type; Type[] types = p.getActualTypeArguments(); // 父类可能有多个泛型 Type firstType = types[0]; // 取第一个泛型 System.out.println(firstType.getTypeName()); &#125;&#125; extends 在平时的继承关系中Integer是Number的子类，但是在泛型中Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类 比如我们定义了一个方法，限定了传入的参数为Pair&lt;Number&gt;类型，如果传入Pair&lt;Integer&gt;就会报错 123static int add(Pair&lt;Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 1234public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p);&#125; 那如何传入Integer呢？这就需要用到extends通配符来解决了，改造一下那个方法 123static int add(Pair&lt;? extends Number&gt; p) &#123; return p.getFirst().intValue() + p.getLast().intValue();&#125; 这种通配符被称为上界通配符，把泛型类型T的上界限定在了Number 使用extends须知： 在add()中是不能获取Integer的引用的，下面代码是无法通过编译的，要求你强制转型 1Integer first = p.getFirst(); 因为我们虽然限定了泛型的上界为Number，但是传入的具体类型到底是Integer还是其他Number的子类是不知道的，编译器只能确定一定是Number的子类 也无法传递Number的子类型给对象的set() 1p.setFirst(new Integer(p.getFirst().intValue() + 100)); 总结一下： 允许调用get()获取Number的引用 不允许调用set(? extends Number)传入任何Number的引用 super 正好和Number相反，传入的是Integer以及它的父类 1Pair&lt;? super Integer&gt; p 使用super须知： 1234567public static void main(String[] args) &#123; Pair&lt;Integer&gt; p = new Pair&lt;&gt;(3,5); Pair.add(p,5);&#125;static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; p.setFirst(n);&#125; 这段代码是可以被正常编译的，因为限定了下界为Integer，无论传入Integer还是它的父类都是可以的 但是无法使用Integer接收get()的返回值，因为无法确定具体返回的是Integer还是它的父类，唯一可以接收的是Object 123static void add(Pair&lt;? super Integer&gt; p,Integer n) &#123; Object first = p.getFirst();&#125; 所以对比extends和super可以发现： &lt;? extends Number&gt;可读不可写 &lt;? super Integer&gt;可写不可读 补充 声明泛型数组时，不能用new操作符创建数组，需强制转型 1Pair&lt;Integer&gt;[] pairs = (Pair&lt;Integer&gt;[]) new Pair[2];","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.xyz/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.xyz/tags/Java/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2022-03-22T05:59:45.000Z","updated":"2022-03-22T12:19:53.883Z","comments":true,"path":"2022/03/22/函数式编程/","link":"","permalink":"http://zouyc.xyz/2022/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FunctionalInterface 我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口： 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 支持函数式编程的都可以使用Lambda表达式 Lambda表达式 当我们用Arrays.sort()排序时，可以传入一个Comparator实例，并采用匿名类的方式来实现： 123456String[] array = ...Arrays.sort(array, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125;); 但是这种写法还是挺繁琐的，所以从JDK8开始，我们可以用Lambda表达式来替代这种繁琐的写法： 1234String[] array = ...Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2);&#125;); 使用Lambda只需要写出方法的定义，参数类型可以省略，编译器会自动推断出String类型，-&gt; &#123; ... &#125;表示方法体，如果只有一行return代码，还可以更加简洁： 1Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2)); 返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。 方法引用 除了使用Lambda之外，还可以直接传入方法引用： 123456789public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(&quot;, &quot;, array));&#125;static int cmp(String s1, String s2) &#123; return s1.compareTo(s2);&#125; 上面的代码是啥意思？可以看到Arrays.sort需传入一个数组和Comparator接口，在Comparator中有个方法int compare(T o1, T o2)，我们自己定义的方法cmp和compare这个方法的方法签名一致，即方法参数和返回类型相同，就可以直接使用方法引用，再看一个例子： 12345public static void main(String[] args) &#123; String[] array = new String[]&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot;&#125;; Arrays.sort(array, String::compareTo); System.out.println(String.join(&quot;, &quot;, array));&#125; 查看String的compareTo方法发现参数只有一个，但是前面不是说方法签名要一致吗，这又是怎么回事？因为之前的方法是个静态方法，这里是一个实例方法，实例方法第一个隐含参数总是传入this，相当于： 1public static int compareTo(this, String o); 所以String::compareTo和compare方法签名是一致的 Stream 一个全新的流失API，可以存储有限或无限个元素，Stream是惰性计算，计算通常时发生在最后结果的获取，因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果： 如何创建一个Stream? Stream.of 1Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;); 数组或Collection 12Stream&lt;String&gt; stream = Arrays.stream(new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;);Stream&lt;String&gt; stream1 = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).stream(); Supplier 通过Stream.generate()需传入Supplier对象 12345public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);&#125; Supplier是一个函数式接口，我们可以自己实现这个接口 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 123456789class NatualSupplier implements Supplier&lt;Integer&gt; &#123; int n = 0; @Override public Integer get() &#123; return n++; &#125;&#125; 基于Supplier创建的Stream会不断调用get()产生下一个元素，可以用来表示无限序列 1234public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.generate(new NatualSupplier()); stream.limit(20).forEach(System.out::println);&#125; 因为它会不断调用get()，我们必须设定一个界限stream.limit(20) 基本类型 因为Java的泛型不支持基本类型的，只能用Integer等包装类型，但是Stream会对频繁的拆箱装箱，所以为了提高效率，Java标准库给我们提供了三种使用基本类型的Stream -&gt; IntStream、LongStream、DoubleStream map Stream.map()是一个转换方法，将一个Stream转为另一个Stream 12Stream&lt;Integer&gt; stream = List.of(1, 2, 3).stream();Stream&lt;Integer&gt; streamMap = stream.map(item -&gt; item * item); 我们看看map()，最终会返回一个新结果的Stream 1234567891011121314/** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;, * &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); Stream.map()传入的是函数式接口Function，apply()最终return计算的结果 123456789101112@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); ...&#125; filter Stream.filter()是Stream的另一个常用转换方法 filter即过滤，过滤掉不满足条件的元素，满足条件的构成一个新的Stream 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Stream&lt;Integer&gt; streamMap = stream.filter(item -&gt; item % 2 == 0); filter接收Predicate，test()过滤掉不满足条件的元素 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t);&#125; reduce 是Stream的一个聚合方法，把一个Stream的所有元素按照聚合函数聚合成一个结果 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();Integer reduce = stream.reduce(0, (acc, n) -&gt; acc + n); Stream.reduce()接收BinaryOperator，而它又继承自BiFunction，在BiFunction中有R apply(T t, U u) 12345678/** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */R apply(T t, U u); 所以BinaryOperator实际上是重写了父接口的方法apply()，通过这个方法进行累加计算 第一个参数0相当于初始值，见源码注释： 123456* &lt;pre&gt;&#123;@code* T result = identity;* for (T element : this stream)* result = accumulator.apply(result, element)* return result;* &#125;&lt;/pre&gt; 输出Stream 对Stream做map()或filter()操作时是不会进行任何计算的，reduce会立即得出结果 如何把进行了转换操作的元素保存下来呢？ 输出为集合： collect()并传入Collectors.toList()对象： 12Stream&lt;Integer&gt; stream = List.of(3, 4, 6).stream();List&lt;Integer&gt; list = stream.map(n -&gt; n * n).collect(Collectors.toList()); 输出为数组： 12Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;).stream();String[] array = stream.toArray(String[]::new); 输出为Map： 12345678Stream&lt;String&gt; stream = List.of(&quot;Apple:Banana&quot;, &quot;Pear:Peach&quot;).stream();Map&lt;String, String&gt; map = stream.collect(Collectors .toMap( // 映射为key s -&gt; s.substring(0, s.indexOf(&#x27;:&#x27;)), // 映射为value s -&gt; s.substring(s.indexOf(&#x27;:&#x27;) + 1) )); 分组输出： 123Stream&lt;String&gt; stream = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Blackberry&quot;, &quot;Coconut&quot;, &quot;Avocado&quot;, &quot;Cherry&quot;, &quot;Apricots&quot;).stream();Map&lt;String, List&lt;String&gt;&gt; groups = stream.collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList())); 上述代码中Collectors.groupingBy以元素的首字母为依据做一个分组","categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.xyz/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.xyz/tags/Java/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://zouyc.xyz/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zouyc.xyz/tags/Java/"}]}